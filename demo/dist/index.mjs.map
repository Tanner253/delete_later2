{"version":3,"sources":["../lib/server.ts","../lib/types.ts","../lib/storage.ts","../lib/utils.ts","../lib/chain.ts","../lib/providers/solana.ts","../lib/webhook.ts","../lib/qrcode.ts","../lib/protocol.ts","../lib/subscription.ts","../lib/storage/memory.ts","../lib/providers/mock.ts","../lib/portal-token.ts"],"sourcesContent":["import express, { Express, Request, Response, NextFunction } from 'express';\r\nimport cors from 'cors';\r\nimport helmet from 'helmet';\r\nimport type {\r\n  PortalConfig,\r\n  PaymentLink,\r\n  Payment,\r\n  CreatePaymentLinkInput,\r\n  Protocol402Response,\r\n  Protocol403Response,\r\n  Storage,\r\n  ChainConfig,\r\n  Subscription,\r\n  CreateSubscriptionInput,\r\n  PaymentOption,\r\n} from './types.js';\r\nimport { ReasonCode, SOLANA_CHAIN_IDS } from './types.js';\r\nimport { MemoryStorage } from './storage.js';\r\nimport { ChainVerifier, MockVerifier } from './chain.js';\r\nimport { SolanaVerifier, MockSolanaVerifier } from './providers/solana.js';\r\nimport { WebhookManager } from './webhook.js';\r\nimport { generatePaymentQR, generateQRCodeSVG, type PaymentQRData } from './qrcode.js';\r\nimport {\r\n  generateId,\r\n  generateUUID,\r\n  generateNonce,\r\n  sign,\r\n  createSignature,\r\n  isExpired,\r\n  isLimitReached,\r\n  REASON_MESSAGES,\r\n} from './utils.js';\r\nimport { build402Response, build403Response, HEADERS_402, HEADERS_403 } from './protocol.js';\r\nimport {\r\n  SubscriptionManager,\r\n  isPaymentDue,\r\n  isInTrialPeriod,\r\n  getIntervalDisplayName,\r\n} from './subscription.js';\r\n\r\ntype Verifier = ChainVerifier | MockVerifier | SolanaVerifier | MockSolanaVerifier;\r\n\r\n/**\r\n * Portal Server\r\n * Self-hosted payment portal with blockchain payment verification\r\n */\r\nexport class PortalServer {\r\n  private app: Express;\r\n  private config: Required<Omit<PortalConfig, 'chains' | 'webhook' | 'portalToken'>> & { \r\n    chains: PortalConfig['chains'];\r\n    webhook?: PortalConfig['webhook'];\r\n    portalToken?: PortalConfig['portalToken'];\r\n  };\r\n  private storage: Storage;\r\n  private verifiers: Map<number, Verifier>;\r\n  \r\n  /**\r\n   * Get verifier for testing (public for test access)\r\n   */\r\n  getVerifier(chainId: number): Verifier | undefined {\r\n    return this.verifiers.get(chainId);\r\n  }\r\n  private webhookManager?: WebhookManager;\r\n  private subscriptionManager: SubscriptionManager;\r\n  private subscriptionCheckInterval?: NodeJS.Timeout;\r\n\r\n  constructor(config: PortalConfig) {\r\n    // Default config\r\n    this.config = {\r\n      port: config.port ?? 3000,\r\n      baseUrl: config.baseUrl ?? '',\r\n      basePath: config.basePath ?? '/pay',\r\n      chains: config.chains,\r\n      paymentTimeout: config.paymentTimeout ?? 900,\r\n      signatureSecret: config.signatureSecret ?? '',\r\n      apiKey: config.apiKey ?? '',\r\n      cors: config.cors ?? true,\r\n      webhook: config.webhook,\r\n      portalToken: config.portalToken,\r\n    };\r\n\r\n    this.storage = new MemoryStorage();\r\n    this.verifiers = new Map();\r\n    this.subscriptionManager = new SubscriptionManager(this.storage);\r\n\r\n    // Initialize webhook manager\r\n    if (config.webhook?.url) {\r\n      this.webhookManager = new WebhookManager(config.webhook);\r\n    }\r\n\r\n    // Initialize chain verifiers\r\n    for (const chain of config.chains) {\r\n      this.verifiers.set(chain.chainId, this.createVerifier(chain));\r\n    }\r\n\r\n    this.app = express();\r\n    this.setupMiddleware();\r\n    this.setupRoutes();\r\n  }\r\n\r\n  /**\r\n   * Create appropriate verifier based on chain type\r\n   */\r\n  private createVerifier(chain: ChainConfig): Verifier {\r\n    const isSolana = chain.type === 'solana' || this.isSolanaChainId(chain.chainId);\r\n    \r\n    if (chain.rpcUrl === 'mock') {\r\n      return isSolana ? new MockSolanaVerifier() : new MockVerifier();\r\n    }\r\n    \r\n    if (isSolana) {\r\n      return new SolanaVerifier({\r\n        rpcUrl: chain.rpcUrl,\r\n        confirmations: chain.confirmations,\r\n      });\r\n    }\r\n    \r\n    return new ChainVerifier(chain);\r\n  }\r\n\r\n  /**\r\n   * Check if chain ID is a Solana chain\r\n   */\r\n  private isSolanaChainId(chainId: number): boolean {\r\n    return chainId === SOLANA_CHAIN_IDS.MAINNET ||\r\n           chainId === SOLANA_CHAIN_IDS.DEVNET ||\r\n           chainId === SOLANA_CHAIN_IDS.TESTNET;\r\n  }\r\n\r\n  /**\r\n   * Get Express app instance\r\n   */\r\n  getApp(): Express {\r\n    return this.app;\r\n  }\r\n\r\n  /**\r\n   * Get storage instance\r\n   */\r\n  getStorage(): Storage {\r\n    return this.storage;\r\n  }\r\n\r\n  /**\r\n   * Set custom storage\r\n   */\r\n  setStorage(storage: Storage): void {\r\n    this.storage = storage;\r\n    this.subscriptionManager = new SubscriptionManager(storage);\r\n  }\r\n\r\n  /**\r\n   * Get subscription manager\r\n   */\r\n  getSubscriptionManager(): SubscriptionManager {\r\n    return this.subscriptionManager;\r\n  }\r\n\r\n  /**\r\n   * Start server\r\n   */\r\n  start(): void {\r\n    // Start subscription payment check\r\n    this.startSubscriptionCheck();\r\n\r\n    this.app.listen(this.config.port, () => {\r\n      console.log('');\r\n      console.log('╔══════════════════════════════════════════════════════════╗');\r\n      console.log('║              Pay Portal Server v1.0.0              ║');\r\n      console.log('╠══════════════════════════════════════════════════════════╣');\r\n      console.log(`║  Port:     ${String(this.config.port).padEnd(44)}║`);\r\n      console.log(`║  Base URL: ${(this.config.baseUrl || 'http://localhost:' + this.config.port).padEnd(44)}║`);\r\n      console.log(`║  Chains:   ${this.config.chains.map(c => c.name).join(', ').padEnd(44)}║`);\r\n      if (this.webhookManager) {\r\n        console.log(`║  Webhook:  ${this.config.webhook?.url?.substring(0, 44).padEnd(44)}║`);\r\n      }\r\n      console.log('╚══════════════════════════════════════════════════════════╝');\r\n      console.log('');\r\n      console.log('Endpoints:');\r\n      console.log(`  GET  ${this.config.basePath}/:id          → Payment page (402/403/302)`);\r\n      console.log(`  GET  ${this.config.basePath}/:id/status   → Check payment status`);\r\n      console.log(`  POST ${this.config.basePath}/:id/confirm  → Confirm with txHash`);\r\n      console.log(`  GET  ${this.config.basePath}/:id/qr       → QR code for payment`);\r\n      console.log('');\r\n      if (this.config.apiKey) {\r\n        console.log('Admin API (X-API-Key header required):');\r\n        console.log('  POST   /api/links       → Create link');\r\n        console.log('  GET    /api/links       → List links');\r\n        console.log('  GET    /api/links/:id   → Get link');\r\n        console.log('  DELETE /api/links/:id   → Disable link');\r\n        console.log('  GET    /api/payments    → List payments');\r\n        console.log('');\r\n      }\r\n    });\r\n  }\r\n\r\n  // ========================================\r\n  // PAYMENT PORTAL METHODS\r\n  // ========================================\r\n\r\n  /**\r\n   * Create a new payment link\r\n   */\r\n  async createPaymentLink(input: CreatePaymentLinkInput): Promise<PaymentLink> {\r\n    const now = new Date();\r\n    \r\n    const paymentLink: PaymentLink = {\r\n      id: generateId(),\r\n      targetUrl: input.targetUrl,\r\n      price: input.price,\r\n      paymentOptions: input.paymentOptions,\r\n      recipientAddress: input.recipientAddress,\r\n      status: 'active',\r\n      createdAt: now,\r\n      updatedAt: now,\r\n      description: input.description,\r\n      maxUses: input.maxUses,\r\n      usedCount: 0,\r\n      expiresAt: input.expiresAt,\r\n      metadata: input.metadata,\r\n      subscription: input.subscription,\r\n    };\r\n\r\n    await this.storage.savePaymentLink(paymentLink);\r\n\r\n    // Send webhook notification\r\n    if (this.webhookManager) {\r\n      this.webhookManager.sendLinkEvent('link.created', paymentLink).catch(err => {\r\n        console.error('Webhook error:', err);\r\n      });\r\n    }\r\n\r\n    return paymentLink;\r\n  }\r\n\r\n  /**\r\n   * Handle payment link request (public API for middleware)\r\n   */\r\n  async handlePaymentLinkRequest(id: string): Promise<{\r\n    type: 'redirect' | 'payment-required' | 'forbidden' | 'not-found';\r\n    targetUrl?: string;\r\n    body?: Protocol402Response | Protocol403Response;\r\n  }> {\r\n    const link = await this.storage.getPaymentLink(id);\r\n\r\n    if (!link) {\r\n      return { type: 'not-found' };\r\n    }\r\n\r\n    // Check if disabled\r\n    if (link.status !== 'active') {\r\n      return {\r\n        type: 'forbidden',\r\n        body: build403Response(ReasonCode.LINK_DISABLED, { paymentLinkId: link.id }),\r\n      };\r\n    }\r\n\r\n    // Check if expired\r\n    if (isExpired(link.expiresAt)) {\r\n      return {\r\n        type: 'forbidden',\r\n        body: build403Response(ReasonCode.LINK_EXPIRED, { paymentLinkId: link.id }),\r\n      };\r\n    }\r\n\r\n    // Check usage limit\r\n    if (isLimitReached(link.usedCount, link.maxUses)) {\r\n      return {\r\n        type: 'forbidden',\r\n        body: build403Response(ReasonCode.LINK_USAGE_LIMIT_REACHED, { paymentLinkId: link.id }),\r\n      };\r\n    }\r\n\r\n    // Check if payment confirmed\r\n    const payment = await this.storage.getConfirmedPayment(id);\r\n    if (payment) {\r\n      // Increment usage count\r\n      link.usedCount = (link.usedCount || 0) + 1;\r\n      await this.storage.updatePaymentLink(link);\r\n      \r\n      return {\r\n        type: 'redirect',\r\n        targetUrl: link.targetUrl,\r\n      };\r\n    }\r\n\r\n    // Payment required\r\n    const nonce = generateNonce();\r\n    const baseUrl = this.config.baseUrl || '';\r\n    \r\n    const response: Protocol402Response = {\r\n      protocol: '402-payportal-v1',\r\n      paymentLinkId: link.id,\r\n      resource: {\r\n        description: link.description || '',\r\n        preview: null,\r\n      },\r\n      payment: {\r\n        chainId: link.price.chainId,\r\n        tokenSymbol: link.price.tokenSymbol,\r\n        amount: link.price.amount,\r\n        recipient: link.recipientAddress,\r\n        timeoutSeconds: this.config.paymentTimeout,\r\n      },\r\n      callbacks: {\r\n        status: `${baseUrl}${this.config.basePath}/${link.id}/status`,\r\n        confirm: `${baseUrl}${this.config.basePath}/${link.id}/confirm`,\r\n      },\r\n      nonce,\r\n    };\r\n\r\n    if (this.config.signatureSecret) {\r\n      const dataToSign = JSON.stringify({\r\n        paymentLinkId: response.paymentLinkId,\r\n        payment: response.payment,\r\n        nonce: response.nonce,\r\n      });\r\n      response.signature = createSignature(dataToSign, this.config.signatureSecret);\r\n    }\r\n\r\n    return {\r\n      type: 'payment-required',\r\n      body: response,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Confirm payment with transaction hash (public API)\r\n   */\r\n  async confirmPayment(paymentLinkId: string, txHash: string): Promise<{\r\n    status: 'confirmed' | 'pending' | 'failed';\r\n    message?: string;\r\n    chainId?: number;\r\n    tokenSymbol?: string;\r\n  }> {\r\n    const link = await this.storage.getPaymentLink(paymentLinkId);\r\n\r\n    if (!link) {\r\n      return { status: 'failed', message: 'Link not found' };\r\n    }\r\n\r\n    // Check if already confirmed\r\n    const existing = await this.storage.getPaymentByTxHash(txHash);\r\n    if (existing?.confirmed) {\r\n      return { status: 'confirmed', message: 'Already confirmed' };\r\n    }\r\n\r\n    // Get verifier for chain\r\n    const verifier = this.verifiers.get(link.price.chainId);\r\n    if (!verifier) {\r\n      return { status: 'failed', message: 'Chain not supported by server' };\r\n    }\r\n\r\n    // Verify payment\r\n    const result = await verifier.verifyPayment({\r\n      txHash,\r\n      recipient: link.recipientAddress,\r\n      amount: link.price.amount,\r\n    });\r\n\r\n    switch (result.status) {\r\n      case 'confirmed': {\r\n        const payment: Payment = {\r\n          id: generateUUID(),\r\n          paymentLinkId: link.id,\r\n          chainId: link.price.chainId,\r\n          txHash,\r\n          fromAddress: result.fromAddress ?? '',\r\n          amount: result.actualAmount ?? link.price.amount,\r\n          tokenSymbol: link.price.tokenSymbol,\r\n          confirmed: true,\r\n          createdAt: new Date(),\r\n          confirmedAt: new Date(),\r\n        };\r\n        await this.storage.savePayment(payment);\r\n        \r\n        // Send webhook notification\r\n        if (this.webhookManager) {\r\n          this.webhookManager.sendPaymentEvent('payment.confirmed', payment, link).catch(err => {\r\n            console.error('Webhook error:', err);\r\n          });\r\n        }\r\n        \r\n        return { status: 'confirmed', chainId: link.price.chainId, tokenSymbol: link.price.tokenSymbol };\r\n      }\r\n      case 'pending':\r\n        // Send webhook for pending payment\r\n        if (this.webhookManager) {\r\n          const pendingPayment: Payment = {\r\n            id: generateUUID(),\r\n            paymentLinkId: link.id,\r\n            chainId: link.price.chainId,\r\n            txHash,\r\n            fromAddress: result.fromAddress ?? '',\r\n            amount: result.actualAmount ?? link.price.amount,\r\n            tokenSymbol: link.price.tokenSymbol,\r\n            confirmed: false,\r\n            createdAt: new Date(),\r\n          };\r\n          this.webhookManager.sendPaymentEvent('payment.pending', pendingPayment, link).catch(err => {\r\n            console.error('Webhook error:', err);\r\n          });\r\n        }\r\n        return { status: 'pending', message: 'Transaction pending' };\r\n      case 'underpaid':\r\n        // Send webhook for underpaid\r\n        if (this.webhookManager) {\r\n          const underpaidPayment: Payment = {\r\n            id: generateUUID(),\r\n            paymentLinkId: link.id,\r\n            chainId: link.price.chainId,\r\n            txHash,\r\n            fromAddress: result.fromAddress ?? '',\r\n            amount: result.actualAmount ?? '0',\r\n            confirmed: false,\r\n            createdAt: new Date(),\r\n          };\r\n          this.webhookManager.sendPaymentEvent('payment.underpaid', underpaidPayment, link).catch(err => {\r\n            console.error('Webhook error:', err);\r\n          });\r\n        }\r\n        return { status: 'failed', message: `Underpaid: received ${result.actualAmount}, required ${link.price.amount}` };\r\n      default:\r\n        return { status: 'failed', message: 'Transaction not found or failed' };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get payment link status (public API)\r\n   */\r\n  async getStatus(paymentLinkId: string): Promise<'unpaid' | 'paid' | 'forbidden' | 'not_found'> {\r\n    const link = await this.storage.getPaymentLink(paymentLinkId);\r\n\r\n    if (!link) {\r\n      return 'not_found';\r\n    }\r\n\r\n    if (link.status !== 'active') {\r\n      return 'forbidden';\r\n    }\r\n\r\n    if (isExpired(link.expiresAt) || isLimitReached(link.usedCount, link.maxUses)) {\r\n      return 'forbidden';\r\n    }\r\n\r\n    const payment = await this.storage.getConfirmedPayment(paymentLinkId);\r\n    return payment ? 'paid' : 'unpaid';\r\n  }\r\n\r\n  /**\r\n   * Get payment link by ID\r\n   */\r\n  async getPaymentLink(id: string): Promise<PaymentLink | null> {\r\n    return this.storage.getPaymentLink(id);\r\n  }\r\n\r\n  /**\r\n   * Disable a payment link\r\n   */\r\n  async disablePaymentLink(id: string): Promise<void> {\r\n    const link = await this.storage.getPaymentLink(id);\r\n    if (!link) throw new Error('Link not found');\r\n    \r\n    link.status = 'disabled';\r\n    await this.storage.updatePaymentLink(link);\r\n\r\n    // Send webhook notification\r\n    if (this.webhookManager) {\r\n      this.webhookManager.sendLinkEvent('link.disabled', link).catch(err => {\r\n        console.error('Webhook error:', err);\r\n      });\r\n    }\r\n  }\r\n\r\n  // ========================================\r\n  // SUBSCRIPTION METHODS\r\n  // ========================================\r\n\r\n  /**\r\n   * Create a subscription for a subscriber\r\n   */\r\n  async createSubscription(\r\n    paymentLinkId: string,\r\n    subscriberAddress: string,\r\n    metadata?: Record<string, unknown>\r\n  ): Promise<Subscription> {\r\n    const link = await this.storage.getPaymentLink(paymentLinkId);\r\n    if (!link) throw new Error('Payment link not found');\r\n    if (!link.subscription) throw new Error('Payment link is not a subscription link');\r\n\r\n    const subscription = await this.subscriptionManager.createSubscription(link, {\r\n      paymentLinkId,\r\n      subscriberAddress,\r\n      metadata,\r\n    });\r\n\r\n    // Send webhook\r\n    if (this.webhookManager) {\r\n      this.webhookManager.sendSubscriptionEvent('subscription.created', subscription, link).catch(err => {\r\n        console.error('Webhook error:', err);\r\n      });\r\n    }\r\n\r\n    return subscription;\r\n  }\r\n\r\n  /**\r\n   * Cancel a subscription\r\n   */\r\n  async cancelSubscription(subscriptionId: string): Promise<Subscription> {\r\n    const subscription = await this.subscriptionManager.cancelSubscription(subscriptionId);\r\n    const link = await this.storage.getPaymentLink(subscription.paymentLinkId);\r\n\r\n    if (this.webhookManager && link) {\r\n      this.webhookManager.sendSubscriptionEvent('subscription.cancelled', subscription, link).catch(err => {\r\n        console.error('Webhook error:', err);\r\n      });\r\n    }\r\n\r\n    return subscription;\r\n  }\r\n\r\n  /**\r\n   * Pause a subscription\r\n   */\r\n  async pauseSubscription(subscriptionId: string): Promise<Subscription> {\r\n    const subscription = await this.subscriptionManager.pauseSubscription(subscriptionId);\r\n    const link = await this.storage.getPaymentLink(subscription.paymentLinkId);\r\n\r\n    if (this.webhookManager && link) {\r\n      this.webhookManager.sendSubscriptionEvent('subscription.paused', subscription, link).catch(err => {\r\n        console.error('Webhook error:', err);\r\n      });\r\n    }\r\n\r\n    return subscription;\r\n  }\r\n\r\n  /**\r\n   * Resume a subscription\r\n   */\r\n  async resumeSubscription(subscriptionId: string): Promise<Subscription> {\r\n    const subscription = await this.subscriptionManager.resumeSubscription(subscriptionId);\r\n    const link = await this.storage.getPaymentLink(subscription.paymentLinkId);\r\n\r\n    if (this.webhookManager && link) {\r\n      this.webhookManager.sendSubscriptionEvent('subscription.resumed', subscription, link).catch(err => {\r\n        console.error('Webhook error:', err);\r\n      });\r\n    }\r\n\r\n    return subscription;\r\n  }\r\n\r\n  /**\r\n   * Get subscription by ID\r\n   */\r\n  async getSubscription(id: string): Promise<Subscription | null> {\r\n    return this.subscriptionManager.getSubscription(id);\r\n  }\r\n\r\n  /**\r\n   * Start periodic subscription check\r\n   */\r\n  private startSubscriptionCheck(): void {\r\n    // Check every minute\r\n    this.subscriptionCheckInterval = setInterval(async () => {\r\n      try {\r\n        const dueSubscriptions = await this.subscriptionManager.getDueSubscriptions();\r\n        \r\n        for (const sub of dueSubscriptions) {\r\n          const link = await this.storage.getPaymentLink(sub.paymentLinkId);\r\n          if (!link) continue;\r\n\r\n          const gracePeriodHours = link.subscription?.gracePeriodHours ?? 24;\r\n          const graceEnd = new Date(sub.nextPaymentDue);\r\n          graceEnd.setHours(graceEnd.getHours() + gracePeriodHours);\r\n\r\n          const now = new Date();\r\n\r\n          // Check if past grace period\r\n          if (now > graceEnd && sub.status === 'active') {\r\n            await this.subscriptionManager.markPastDue(sub.id);\r\n            \r\n            if (this.webhookManager) {\r\n              const updated = await this.subscriptionManager.getSubscription(sub.id);\r\n              if (updated) {\r\n                this.webhookManager.sendSubscriptionEvent('subscription.past_due', updated, link).catch(err => {\r\n                  console.error('Webhook error:', err);\r\n                });\r\n              }\r\n            }\r\n          } else if (sub.status === 'active') {\r\n            // Send payment due webhook\r\n            if (this.webhookManager) {\r\n              this.webhookManager.sendSubscriptionEvent('subscription.payment_due', sub, link).catch(err => {\r\n                console.error('Webhook error:', err);\r\n              });\r\n            }\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error('Subscription check error:', error);\r\n      }\r\n    }, 60000);\r\n  }\r\n\r\n  /**\r\n   * Stop subscription check\r\n   */\r\n  stopSubscriptionCheck(): void {\r\n    if (this.subscriptionCheckInterval) {\r\n      clearInterval(this.subscriptionCheckInterval);\r\n      this.subscriptionCheckInterval = undefined;\r\n    }\r\n  }\r\n\r\n  // ========================================\r\n  // PRIVATE METHODS\r\n  // ========================================\r\n\r\n  private setupMiddleware(): void {\r\n    this.app.use(helmet());\r\n    \r\n    if (this.config.cors) {\r\n      this.app.use(cors({ origin: '*', methods: ['GET', 'POST', 'DELETE'] }));\r\n    }\r\n    \r\n    this.app.use(express.json());\r\n    this.app.set('trust proxy', 1);\r\n\r\n    // Request logging\r\n    this.app.use((req, res, next) => {\r\n      const start = Date.now();\r\n      res.on('finish', () => {\r\n        console.log(`${req.method} ${req.path} ${res.statusCode} ${Date.now() - start}ms`);\r\n      });\r\n      next();\r\n    });\r\n  }\r\n\r\n  private setupRoutes(): void {\r\n    // Health check\r\n    this.app.get('/health', (req, res) => {\r\n      res.json({ status: 'ok', timestamp: new Date().toISOString() });\r\n    });\r\n\r\n    // API info\r\n    this.app.get('/', (req, res) => {\r\n      const base = this.config.baseUrl || `http://localhost:${this.config.port}`;\r\n      res.json({\r\n        name: 'Pay Portal',\r\n        version: '1.3.0',\r\n        chains: this.config.chains.map(c => ({ id: c.chainId, name: c.name, symbol: c.symbol })),\r\n        endpoints: {\r\n          portal: `${base}${this.config.basePath}/:id`,\r\n          status: `${base}${this.config.basePath}/:id/status`,\r\n          confirm: `${base}${this.config.basePath}/:id/confirm`,\r\n          subscribe: `${base}${this.config.basePath}/:id/subscribe`,\r\n        },\r\n      });\r\n    });\r\n\r\n    // Payment portal routes\r\n    this.app.get(`${this.config.basePath}/:id`, this.handlePaymentLink.bind(this));\r\n    this.app.get(`${this.config.basePath}/:id/status`, this.handleStatus.bind(this));\r\n    this.app.post(`${this.config.basePath}/:id/confirm`, this.handleConfirm.bind(this));\r\n    this.app.get(`${this.config.basePath}/:id/qr`, this.handleQRCode.bind(this));\r\n    \r\n    // Subscription routes\r\n    this.app.post(`${this.config.basePath}/:id/subscribe`, this.handleSubscribe.bind(this));\r\n    this.app.get(`${this.config.basePath}/:id/subscription`, this.handleGetSubscription.bind(this));\r\n\r\n    // Admin API\r\n    if (this.config.apiKey) {\r\n      const auth = this.authMiddleware.bind(this);\r\n      this.app.post('/api/links', auth, this.apiCreateLink.bind(this));\r\n      this.app.get('/api/links', auth, this.apiListLinks.bind(this));\r\n      this.app.get('/api/links/:id', auth, this.apiGetLink.bind(this));\r\n      this.app.delete('/api/links/:id', auth, this.apiDeleteLink.bind(this));\r\n      this.app.get('/api/payments', auth, this.apiListPayments.bind(this));\r\n      \r\n      // Subscription admin routes\r\n      this.app.get('/api/subscriptions', auth, this.apiListSubscriptions.bind(this));\r\n      this.app.get('/api/subscriptions/:id', auth, this.apiGetSubscription.bind(this));\r\n      this.app.post('/api/subscriptions/:id/cancel', auth, this.apiCancelSubscription.bind(this));\r\n      this.app.post('/api/subscriptions/:id/pause', auth, this.apiPauseSubscription.bind(this));\r\n      this.app.post('/api/subscriptions/:id/resume', auth, this.apiResumeSubscription.bind(this));\r\n    }\r\n  }\r\n\r\n  private authMiddleware(req: Request, res: Response, next: NextFunction): void {\r\n    const key = req.headers['x-api-key'];\r\n    if (key !== this.config.apiKey) {\r\n      res.status(401).json({ error: 'Invalid API key' });\r\n      return;\r\n    }\r\n    next();\r\n  }\r\n\r\n  // ========================================\r\n  // PAYMENT PORTAL HANDLERS\r\n  // ========================================\r\n\r\n  private async handlePaymentLink(req: Request, res: Response): Promise<void> {\r\n    try {\r\n      const link = await this.storage.getPaymentLink(req.params.id);\r\n\r\n      if (!link) {\r\n        res.status(404).json({ error: 'Payment link not found' });\r\n        return;\r\n      }\r\n\r\n      // Check if disabled\r\n      if (link.status !== 'active') {\r\n        this.send403(res, ReasonCode.LINK_DISABLED, link.id);\r\n        return;\r\n      }\r\n\r\n      // Check if expired\r\n      if (isExpired(link.expiresAt)) {\r\n        this.send403(res, ReasonCode.LINK_EXPIRED, link.id, {\r\n          expiredAt: link.expiresAt?.toISOString(),\r\n        });\r\n        return;\r\n      }\r\n\r\n      // Check usage limit (for non-subscription links)\r\n      if (!link.subscription && isLimitReached(link.usedCount, link.maxUses)) {\r\n        this.send403(res, ReasonCode.LINK_USAGE_LIMIT_REACHED, link.id, {\r\n          maxUses: link.maxUses,\r\n          usedCount: link.usedCount,\r\n        });\r\n        return;\r\n      }\r\n\r\n      // Handle subscription links\r\n      if (link.subscription) {\r\n        const subscriberAddress = req.query.subscriber as string;\r\n        \r\n        if (subscriberAddress) {\r\n          const subscription = await this.storage.getSubscriptionByAddress(link.id, subscriberAddress);\r\n          \r\n          if (subscription) {\r\n            const access = await this.subscriptionManager.checkAccess(subscription, link);\r\n            \r\n            if (access.hasAccess) {\r\n              // Grant access\r\n              res.redirect(302, link.targetUrl);\r\n              return;\r\n            }\r\n            \r\n            // Check subscription status and return appropriate error\r\n            if (subscription.status === 'cancelled') {\r\n              this.send403(res, ReasonCode.SUBSCRIPTION_CANCELLED, link.id, {\r\n                subscriptionId: subscription.id,\r\n                cancelledAt: subscription.cancelledAt?.toISOString(),\r\n              });\r\n              return;\r\n            }\r\n            \r\n            if (subscription.status === 'paused') {\r\n              this.send403(res, ReasonCode.SUBSCRIPTION_PAUSED, link.id, {\r\n                subscriptionId: subscription.id,\r\n                pausedAt: subscription.pausedAt?.toISOString(),\r\n              });\r\n              return;\r\n            }\r\n            \r\n            if (subscription.status === 'expired') {\r\n              this.send403(res, ReasonCode.SUBSCRIPTION_EXPIRED, link.id, {\r\n                subscriptionId: subscription.id,\r\n              });\r\n              return;\r\n            }\r\n            \r\n            if (subscription.status === 'past_due') {\r\n              // Return 402 with subscription info for renewal\r\n              this.send402(res, link, subscription);\r\n              return;\r\n            }\r\n          }\r\n        }\r\n        \r\n        // No subscription or subscriber address - return 402 for new subscription\r\n        this.send402(res, link);\r\n        return;\r\n      }\r\n\r\n      // Check for confirmed payment (one-time links)\r\n      const payment = await this.storage.getConfirmedPayment(link.id);\r\n\r\n      if (payment) {\r\n        // Increment usage and redirect\r\n        link.usedCount = (link.usedCount ?? 0) + 1;\r\n        await this.storage.updatePaymentLink(link);\r\n        res.redirect(302, link.targetUrl);\r\n        return;\r\n      }\r\n\r\n      // No payment - return 402\r\n      this.send402(res, link);\r\n    } catch (error) {\r\n      console.error('PaymentLink error:', error);\r\n      res.status(500).json({ error: 'Internal server error' });\r\n    }\r\n  }\r\n\r\n  private async handleStatus(req: Request, res: Response): Promise<void> {\r\n    try {\r\n      const link = await this.storage.getPaymentLink(req.params.id);\r\n\r\n      if (!link) {\r\n        res.json({ status: 'not_found' });\r\n        return;\r\n      }\r\n\r\n      if (link.status !== 'active') {\r\n        res.json({ status: 'forbidden' });\r\n        return;\r\n      }\r\n\r\n      if (isExpired(link.expiresAt) || isLimitReached(link.usedCount, link.maxUses)) {\r\n        res.json({ status: 'forbidden' });\r\n        return;\r\n      }\r\n\r\n      const payment = await this.storage.getConfirmedPayment(link.id);\r\n      res.json({ status: payment ? 'paid' : 'unpaid' });\r\n    } catch (error) {\r\n      console.error('Status error:', error);\r\n      res.status(500).json({ error: 'Internal server error' });\r\n    }\r\n  }\r\n\r\n  private async handleConfirm(req: Request, res: Response): Promise<void> {\r\n    try {\r\n      const { txHash, chainId: requestedChainId } = req.body;\r\n\r\n      if (!txHash || typeof txHash !== 'string') {\r\n        res.status(400).json({ status: 'failed', message: 'Missing txHash' });\r\n        return;\r\n      }\r\n\r\n      const link = await this.storage.getPaymentLink(req.params.id);\r\n\r\n      if (!link) {\r\n        res.status(404).json({ status: 'failed', message: 'Link not found' });\r\n        return;\r\n      }\r\n\r\n      // Check if already confirmed\r\n      const existing = await this.storage.getPaymentByTxHash(txHash);\r\n      if (existing?.confirmed) {\r\n        res.json({ status: 'confirmed', message: 'Already confirmed' });\r\n        return;\r\n      }\r\n\r\n      // Determine which payment option to verify\r\n      let chainId = link.price.chainId;\r\n      let expectedAmount = link.price.amount;\r\n      let recipient = link.recipientAddress;\r\n      let tokenSymbol = link.price.tokenSymbol;\r\n\r\n      // If chainId provided in request, find matching payment option\r\n      if (requestedChainId !== undefined) {\r\n        const numChainId = Number(requestedChainId);\r\n        \r\n        if (numChainId === link.price.chainId) {\r\n          // Primary price matches\r\n          chainId = link.price.chainId;\r\n          expectedAmount = link.price.amount;\r\n          tokenSymbol = link.price.tokenSymbol;\r\n        } else if (link.paymentOptions) {\r\n          // Look for matching payment option\r\n          const option = link.paymentOptions.find(opt => opt.chainId === numChainId);\r\n          if (option) {\r\n            chainId = option.chainId;\r\n            expectedAmount = option.amount;\r\n            tokenSymbol = option.tokenSymbol;\r\n            recipient = option.recipientAddress || link.recipientAddress;\r\n          } else {\r\n            res.status(400).json({ status: 'failed', message: 'Chain not accepted for this payment link' });\r\n            return;\r\n          }\r\n        } else {\r\n          res.status(400).json({ status: 'failed', message: 'Chain not accepted for this payment link' });\r\n          return;\r\n        }\r\n      }\r\n\r\n      // Get verifier for chain\r\n      const verifier = this.verifiers.get(chainId);\r\n      if (!verifier) {\r\n        res.status(400).json({ status: 'failed', message: 'Chain not supported by server' });\r\n        return;\r\n      }\r\n\r\n      // Verify payment\r\n      const result = await verifier.verifyPayment({\r\n        txHash,\r\n        recipient,\r\n        amount: expectedAmount,\r\n      });\r\n\r\n      switch (result.status) {\r\n        case 'confirmed': {\r\n          const payment: Payment = {\r\n            id: generateUUID(),\r\n            paymentLinkId: link.id,\r\n            chainId,\r\n            txHash,\r\n            fromAddress: result.fromAddress ?? '',\r\n            amount: result.actualAmount ?? expectedAmount,\r\n            tokenSymbol,\r\n            confirmed: true,\r\n            createdAt: new Date(),\r\n            confirmedAt: new Date(),\r\n          };\r\n          await this.storage.savePayment(payment);\r\n          \r\n          // Send webhook notification\r\n          if (this.webhookManager) {\r\n            this.webhookManager.sendPaymentEvent('payment.confirmed', payment, link).catch(err => {\r\n              console.error('Webhook error:', err);\r\n            });\r\n          }\r\n          \r\n          res.json({ status: 'confirmed', chainId, tokenSymbol });\r\n          break;\r\n        }\r\n        case 'pending':\r\n          // Send webhook for pending payment\r\n          if (this.webhookManager) {\r\n            const pendingPayment: Payment = {\r\n              id: generateUUID(),\r\n              paymentLinkId: link.id,\r\n              chainId,\r\n              txHash,\r\n              fromAddress: result.fromAddress ?? '',\r\n              amount: result.actualAmount ?? expectedAmount,\r\n              tokenSymbol,\r\n              confirmed: false,\r\n              createdAt: new Date(),\r\n            };\r\n            this.webhookManager.sendPaymentEvent('payment.pending', pendingPayment, link).catch(err => {\r\n              console.error('Webhook error:', err);\r\n            });\r\n          }\r\n          res.status(202).json({ status: 'pending', message: 'Transaction pending' });\r\n          break;\r\n        case 'underpaid':\r\n          // Send webhook for underpaid\r\n          if (this.webhookManager) {\r\n            const underpaidPayment: Payment = {\r\n              id: generateUUID(),\r\n              paymentLinkId: link.id,\r\n              chainId,\r\n              txHash,\r\n              fromAddress: result.fromAddress ?? '',\r\n              amount: result.actualAmount ?? '0',\r\n              confirmed: false,\r\n              createdAt: new Date(),\r\n            };\r\n            this.webhookManager.sendPaymentEvent('payment.underpaid', underpaidPayment, link).catch(err => {\r\n              console.error('Webhook error:', err);\r\n            });\r\n          }\r\n          res.status(400).json({\r\n            status: 'failed',\r\n            message: `Underpaid: received ${result.actualAmount}, required ${link.price.amount}`,\r\n          });\r\n          break;\r\n        default:\r\n          res.status(400).json({ status: 'failed', message: 'Transaction not found or failed' });\r\n      }\r\n    } catch (error) {\r\n      console.error('Confirm error:', error);\r\n      res.status(500).json({ error: 'Internal server error' });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle QR code generation\r\n   */\r\n  private async handleQRCode(req: Request, res: Response): Promise<void> {\r\n    try {\r\n      const link = await this.storage.getPaymentLink(req.params.id);\r\n\r\n      if (!link) {\r\n        res.status(404).json({ error: 'Payment link not found' });\r\n        return;\r\n      }\r\n\r\n      if (link.status !== 'active') {\r\n        res.status(403).json({ error: 'Payment link is not active' });\r\n        return;\r\n      }\r\n\r\n      const base = this.config.baseUrl || `http://localhost:${this.config.port}`;\r\n      const format = req.query.format as string || 'svg';\r\n      const size = parseInt(req.query.size as string) || 256;\r\n\r\n      const qrData: PaymentQRData = {\r\n        chainId: link.price.chainId,\r\n        recipient: link.recipientAddress,\r\n        amount: link.price.amount,\r\n        tokenSymbol: link.price.tokenSymbol,\r\n        paymentLinkId: link.id,\r\n        confirmUrl: `${base}${this.config.basePath}/${link.id}/confirm`,\r\n      };\r\n\r\n      const qr = generatePaymentQR(qrData, { size });\r\n\r\n      if (format === 'json') {\r\n        res.json({\r\n          paymentLinkId: link.id,\r\n          paymentUri: qr.uri,\r\n          qrCodeDataUrl: qr.dataUrl,\r\n          payment: {\r\n            chainId: link.price.chainId,\r\n            tokenSymbol: link.price.tokenSymbol,\r\n            amount: link.price.amount,\r\n            recipient: link.recipientAddress,\r\n          },\r\n        });\r\n        return;\r\n      }\r\n\r\n      // Return SVG directly\r\n      res.set({\r\n        'Content-Type': 'image/svg+xml',\r\n        'Cache-Control': 'public, max-age=300',\r\n      });\r\n      res.send(qr.svg);\r\n    } catch (error) {\r\n      console.error('QR code error:', error);\r\n      res.status(500).json({ error: 'Internal server error' });\r\n    }\r\n  }\r\n\r\n  // ========================================\r\n  // SUBSCRIPTION HANDLERS\r\n  // ========================================\r\n\r\n  /**\r\n   * Handle subscription creation/renewal\r\n   */\r\n  private async handleSubscribe(req: Request, res: Response): Promise<void> {\r\n    try {\r\n      const { subscriberAddress, txHash } = req.body;\r\n\r\n      if (!subscriberAddress) {\r\n        res.status(400).json({ error: 'Missing subscriberAddress' });\r\n        return;\r\n      }\r\n\r\n      const link = await this.storage.getPaymentLink(req.params.id);\r\n\r\n      if (!link) {\r\n        res.status(404).json({ error: 'Payment link not found' });\r\n        return;\r\n      }\r\n\r\n      if (!link.subscription) {\r\n        res.status(400).json({ error: 'This link does not support subscriptions' });\r\n        return;\r\n      }\r\n\r\n      // Check for existing subscription\r\n      let subscription = await this.storage.getSubscriptionByAddress(link.id, subscriberAddress);\r\n\r\n      // If txHash provided, verify payment first\r\n      if (txHash) {\r\n        const verifier = this.verifiers.get(link.price.chainId);\r\n        if (!verifier) {\r\n          res.status(400).json({ error: 'Chain not supported' });\r\n          return;\r\n        }\r\n\r\n        const result = await verifier.verifyPayment({\r\n          txHash,\r\n          recipient: link.recipientAddress,\r\n          amount: link.price.amount,\r\n        });\r\n\r\n        if (result.status !== 'confirmed') {\r\n          res.status(400).json({\r\n            error: 'Payment not confirmed',\r\n            status: result.status,\r\n          });\r\n          return;\r\n        }\r\n\r\n        // Save payment\r\n        const payment: Payment = {\r\n          id: generateUUID(),\r\n          paymentLinkId: link.id,\r\n          chainId: link.price.chainId,\r\n          txHash,\r\n          fromAddress: result.fromAddress ?? subscriberAddress,\r\n          amount: result.actualAmount ?? link.price.amount,\r\n          confirmed: true,\r\n          createdAt: new Date(),\r\n          confirmedAt: new Date(),\r\n        };\r\n        await this.storage.savePayment(payment);\r\n\r\n        // Send payment webhook\r\n        if (this.webhookManager) {\r\n          this.webhookManager.sendPaymentEvent('payment.confirmed', payment, link).catch(err => {\r\n            console.error('Webhook error:', err);\r\n          });\r\n        }\r\n\r\n        if (subscription) {\r\n          // Renew existing subscription\r\n          subscription = await this.subscriptionManager.processPayment(subscription, payment, link);\r\n\r\n          if (this.webhookManager) {\r\n            this.webhookManager.sendSubscriptionEvent('subscription.renewed', subscription, link).catch(err => {\r\n              console.error('Webhook error:', err);\r\n            });\r\n          }\r\n\r\n          res.json({\r\n            success: true,\r\n            action: 'renewed',\r\n            subscription: this.formatSubscriptionResponse(subscription, link),\r\n          });\r\n          return;\r\n        }\r\n      }\r\n\r\n      // Create new subscription\r\n      if (!subscription) {\r\n        subscription = await this.createSubscription(link.id, subscriberAddress);\r\n\r\n        res.status(201).json({\r\n          success: true,\r\n          action: 'created',\r\n          subscription: this.formatSubscriptionResponse(subscription, link),\r\n        });\r\n        return;\r\n      }\r\n\r\n      // Return existing subscription info\r\n      res.json({\r\n        success: true,\r\n        action: 'existing',\r\n        subscription: this.formatSubscriptionResponse(subscription, link),\r\n      });\r\n    } catch (error) {\r\n      console.error('Subscribe error:', error);\r\n      res.status(500).json({ error: 'Internal server error' });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle get subscription status\r\n   */\r\n  private async handleGetSubscription(req: Request, res: Response): Promise<void> {\r\n    try {\r\n      const subscriberAddress = req.query.subscriber as string;\r\n\r\n      if (!subscriberAddress) {\r\n        res.status(400).json({ error: 'Missing subscriber query parameter' });\r\n        return;\r\n      }\r\n\r\n      const link = await this.storage.getPaymentLink(req.params.id);\r\n\r\n      if (!link) {\r\n        res.status(404).json({ error: 'Payment link not found' });\r\n        return;\r\n      }\r\n\r\n      const subscription = await this.storage.getSubscriptionByAddress(link.id, subscriberAddress);\r\n\r\n      if (!subscription) {\r\n        res.status(404).json({ error: 'Subscription not found' });\r\n        return;\r\n      }\r\n\r\n      const access = await this.subscriptionManager.checkAccess(subscription, link);\r\n\r\n      res.json({\r\n        subscription: this.formatSubscriptionResponse(subscription, link),\r\n        access: {\r\n          hasAccess: access.hasAccess,\r\n          reason: access.reason,\r\n          requiresPayment: access.requiresPayment,\r\n        },\r\n      });\r\n    } catch (error) {\r\n      console.error('Get subscription error:', error);\r\n      res.status(500).json({ error: 'Internal server error' });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Format subscription for response\r\n   */\r\n  private formatSubscriptionResponse(subscription: Subscription, link: PaymentLink) {\r\n    const base = this.config.baseUrl || `http://localhost:${this.config.port}`;\r\n    \r\n    return {\r\n      id: subscription.id,\r\n      paymentLinkId: subscription.paymentLinkId,\r\n      subscriberAddress: subscription.subscriberAddress,\r\n      status: subscription.status,\r\n      interval: link.subscription?.interval,\r\n      intervalCount: link.subscription?.intervalCount ?? 1,\r\n      currentPeriodStart: subscription.currentPeriodStart.toISOString(),\r\n      currentPeriodEnd: subscription.currentPeriodEnd.toISOString(),\r\n      nextPaymentDue: subscription.nextPaymentDue.toISOString(),\r\n      cycleCount: subscription.cycleCount,\r\n      trialEndsAt: subscription.trialEndsAt?.toISOString(),\r\n      cancelledAt: subscription.cancelledAt?.toISOString(),\r\n      pausedAt: subscription.pausedAt?.toISOString(),\r\n      createdAt: subscription.createdAt.toISOString(),\r\n      price: link.price,\r\n      renewUrl: `${base}${this.config.basePath}/${link.id}/subscribe`,\r\n    };\r\n  }\r\n\r\n  // ========================================\r\n  // ADMIN API HANDLERS\r\n  // ========================================\r\n\r\n  private async apiCreateLink(req: Request, res: Response): Promise<void> {\r\n    try {\r\n      const {\r\n        targetUrl,\r\n        amount,\r\n        tokenSymbol = 'ETH',\r\n        chainId = 1,\r\n        recipientAddress,\r\n        description,\r\n        maxUses,\r\n        expiresIn,\r\n        // Multi-currency payment options\r\n        paymentOptions,\r\n        // Subscription fields\r\n        subscription,\r\n      } = req.body;\r\n\r\n      if (!targetUrl || !amount || !recipientAddress) {\r\n        res.status(400).json({ error: 'Missing: targetUrl, amount, or recipientAddress' });\r\n        return;\r\n      }\r\n\r\n      // Parse payment options if provided\r\n      let parsedPaymentOptions: PaymentOption[] | undefined;\r\n      if (paymentOptions && Array.isArray(paymentOptions)) {\r\n        parsedPaymentOptions = paymentOptions.map((opt: any) => ({\r\n          tokenSymbol: opt.tokenSymbol,\r\n          chainId: Number(opt.chainId),\r\n          amount: String(opt.amount),\r\n          recipientAddress: opt.recipientAddress,\r\n        }));\r\n      }\r\n\r\n      // Parse subscription config if provided\r\n      let subscriptionConfig;\r\n      if (subscription) {\r\n        if (!subscription.interval || !['daily', 'weekly', 'monthly', 'yearly'].includes(subscription.interval)) {\r\n          res.status(400).json({ error: 'Invalid subscription interval. Must be: daily, weekly, monthly, or yearly' });\r\n          return;\r\n        }\r\n        subscriptionConfig = {\r\n          interval: subscription.interval,\r\n          intervalCount: subscription.intervalCount ? Number(subscription.intervalCount) : 1,\r\n          gracePeriodHours: subscription.gracePeriodHours ? Number(subscription.gracePeriodHours) : 24,\r\n          maxCycles: subscription.maxCycles ? Number(subscription.maxCycles) : undefined,\r\n          trialDays: subscription.trialDays ? Number(subscription.trialDays) : 0,\r\n        };\r\n      }\r\n\r\n      const link = await this.createPaymentLink({\r\n        targetUrl,\r\n        price: { amount: String(amount), tokenSymbol, chainId: Number(chainId) },\r\n        paymentOptions: parsedPaymentOptions,\r\n        recipientAddress,\r\n        description,\r\n        maxUses: maxUses ? Number(maxUses) : undefined,\r\n        expiresAt: expiresIn ? new Date(Date.now() + Number(expiresIn) * 1000) : undefined,\r\n        subscription: subscriptionConfig,\r\n      });\r\n\r\n      const base = this.config.baseUrl || `http://localhost:${this.config.port}`;\r\n\r\n      res.status(201).json({\r\n        success: true,\r\n        link: {\r\n          id: link.id,\r\n          url: `${base}${this.config.basePath}/${link.id}`,\r\n          targetUrl: link.targetUrl,\r\n          price: link.price,\r\n          paymentOptions: link.paymentOptions,\r\n          recipientAddress: link.recipientAddress,\r\n          description: link.description,\r\n          maxUses: link.maxUses,\r\n          expiresAt: link.expiresAt?.toISOString(),\r\n          subscription: link.subscription ? {\r\n            interval: link.subscription.interval,\r\n            intervalCount: link.subscription.intervalCount,\r\n            gracePeriodHours: link.subscription.gracePeriodHours,\r\n            maxCycles: link.subscription.maxCycles,\r\n            trialDays: link.subscription.trialDays,\r\n            subscribeUrl: `${base}${this.config.basePath}/${link.id}/subscribe`,\r\n          } : undefined,\r\n        },\r\n      });\r\n    } catch (error) {\r\n      console.error('Create link error:', error);\r\n      res.status(500).json({ error: 'Internal server error' });\r\n    }\r\n  }\r\n\r\n  private async apiListLinks(req: Request, res: Response): Promise<void> {\r\n    const links = await this.storage.getAllPaymentLinks();\r\n    const base = this.config.baseUrl || `http://localhost:${this.config.port}`;\r\n\r\n    res.json({\r\n      count: links.length,\r\n      links: links.map(l => ({\r\n        id: l.id,\r\n        url: `${base}${this.config.basePath}/${l.id}`,\r\n        status: l.status,\r\n        price: l.price,\r\n        usedCount: l.usedCount,\r\n        isSubscription: !!l.subscription,\r\n        subscription: l.subscription,\r\n      })),\r\n    });\r\n  }\r\n\r\n  private async apiGetLink(req: Request, res: Response): Promise<void> {\r\n    const link = await this.storage.getPaymentLink(req.params.id);\r\n\r\n    if (!link) {\r\n      res.status(404).json({ error: 'Link not found' });\r\n      return;\r\n    }\r\n\r\n    const base = this.config.baseUrl || `http://localhost:${this.config.port}`;\r\n\r\n    res.json({\r\n      id: link.id,\r\n      url: `${base}${this.config.basePath}/${link.id}`,\r\n      targetUrl: link.targetUrl,\r\n      price: link.price,\r\n      recipientAddress: link.recipientAddress,\r\n      status: link.status,\r\n      usedCount: link.usedCount,\r\n      maxUses: link.maxUses,\r\n      expiresAt: link.expiresAt?.toISOString(),\r\n      createdAt: link.createdAt.toISOString(),\r\n    });\r\n  }\r\n\r\n  private async apiDeleteLink(req: Request, res: Response): Promise<void> {\r\n    try {\r\n      await this.disablePaymentLink(req.params.id);\r\n      res.json({ success: true });\r\n    } catch {\r\n      res.status(404).json({ error: 'Link not found' });\r\n    }\r\n  }\r\n\r\n  private async apiListPayments(req: Request, res: Response): Promise<void> {\r\n    const payments = await this.storage.getAllPayments();\r\n\r\n    res.json({\r\n      count: payments.length,\r\n      payments: payments.map(p => ({\r\n        id: p.id,\r\n        paymentLinkId: p.paymentLinkId,\r\n        txHash: p.txHash,\r\n        amount: p.amount,\r\n        confirmed: p.confirmed,\r\n        createdAt: p.createdAt.toISOString(),\r\n      })),\r\n    });\r\n  }\r\n\r\n  // ========================================\r\n  // SUBSCRIPTION ADMIN ENDPOINTS\r\n  // ========================================\r\n\r\n  private async apiListSubscriptions(req: Request, res: Response): Promise<void> {\r\n    const subscriptions = await this.storage.getAllSubscriptions();\r\n    \r\n    res.json({\r\n      count: subscriptions.length,\r\n      subscriptions: subscriptions.map(s => ({\r\n        id: s.id,\r\n        paymentLinkId: s.paymentLinkId,\r\n        subscriberAddress: s.subscriberAddress,\r\n        status: s.status,\r\n        cycleCount: s.cycleCount,\r\n        nextPaymentDue: s.nextPaymentDue.toISOString(),\r\n        createdAt: s.createdAt.toISOString(),\r\n      })),\r\n    });\r\n  }\r\n\r\n  private async apiGetSubscription(req: Request, res: Response): Promise<void> {\r\n    const subscription = await this.storage.getSubscription(req.params.id);\r\n    \r\n    if (!subscription) {\r\n      res.status(404).json({ error: 'Subscription not found' });\r\n      return;\r\n    }\r\n\r\n    const link = await this.storage.getPaymentLink(subscription.paymentLinkId);\r\n\r\n    res.json({\r\n      id: subscription.id,\r\n      paymentLinkId: subscription.paymentLinkId,\r\n      subscriberAddress: subscription.subscriberAddress,\r\n      status: subscription.status,\r\n      currentPeriodStart: subscription.currentPeriodStart.toISOString(),\r\n      currentPeriodEnd: subscription.currentPeriodEnd.toISOString(),\r\n      nextPaymentDue: subscription.nextPaymentDue.toISOString(),\r\n      cycleCount: subscription.cycleCount,\r\n      lastPaymentId: subscription.lastPaymentId,\r\n      trialEndsAt: subscription.trialEndsAt?.toISOString(),\r\n      cancelledAt: subscription.cancelledAt?.toISOString(),\r\n      pausedAt: subscription.pausedAt?.toISOString(),\r\n      createdAt: subscription.createdAt.toISOString(),\r\n      updatedAt: subscription.updatedAt.toISOString(),\r\n      paymentLink: link ? {\r\n        id: link.id,\r\n        targetUrl: link.targetUrl,\r\n        price: link.price,\r\n        subscription: link.subscription,\r\n      } : undefined,\r\n    });\r\n  }\r\n\r\n  private async apiCancelSubscription(req: Request, res: Response): Promise<void> {\r\n    try {\r\n      const subscription = await this.cancelSubscription(req.params.id);\r\n      res.json({ success: true, subscription: { id: subscription.id, status: subscription.status } });\r\n    } catch (error) {\r\n      res.status(404).json({ error: (error as Error).message });\r\n    }\r\n  }\r\n\r\n  private async apiPauseSubscription(req: Request, res: Response): Promise<void> {\r\n    try {\r\n      const subscription = await this.pauseSubscription(req.params.id);\r\n      res.json({ success: true, subscription: { id: subscription.id, status: subscription.status } });\r\n    } catch (error) {\r\n      res.status(400).json({ error: (error as Error).message });\r\n    }\r\n  }\r\n\r\n  private async apiResumeSubscription(req: Request, res: Response): Promise<void> {\r\n    try {\r\n      const subscription = await this.resumeSubscription(req.params.id);\r\n      res.json({ success: true, subscription: { id: subscription.id, status: subscription.status } });\r\n    } catch (error) {\r\n      res.status(400).json({ error: (error as Error).message });\r\n    }\r\n  }\r\n\r\n  // ========================================\r\n  // RESPONSE HELPERS\r\n  // ========================================\r\n\r\n  private send402(res: Response, link: PaymentLink, subscription?: Subscription): void {\r\n    const base = this.config.baseUrl || `http://localhost:${this.config.port}`;\r\n    const nonce = generateNonce();\r\n\r\n    const body: Protocol402Response = {\r\n      protocol: '402-payportal-v1',\r\n      paymentLinkId: link.id,\r\n      resource: {\r\n        description: link.description,\r\n        preview: null,\r\n      },\r\n      payment: {\r\n        chainId: link.price.chainId,\r\n        tokenSymbol: link.price.tokenSymbol,\r\n        amount: link.price.amount,\r\n        recipient: link.recipientAddress,\r\n        timeoutSeconds: this.config.paymentTimeout,\r\n      },\r\n      callbacks: {\r\n        status: `${base}${this.config.basePath}/${link.id}/status`,\r\n        confirm: `${base}${this.config.basePath}/${link.id}/confirm`,\r\n      },\r\n      nonce,\r\n    };\r\n\r\n    // Add multi-currency payment options\r\n    if (link.paymentOptions && link.paymentOptions.length > 0) {\r\n      body.paymentOptions = link.paymentOptions.map(opt => ({\r\n        chainId: opt.chainId,\r\n        tokenSymbol: opt.tokenSymbol,\r\n        amount: opt.amount,\r\n        recipient: opt.recipientAddress || link.recipientAddress,\r\n      }));\r\n    }\r\n\r\n    // Add subscription info if this is a subscription link\r\n    if (link.subscription) {\r\n      body.subscription = {\r\n        interval: link.subscription.interval,\r\n        intervalCount: link.subscription.intervalCount ?? 1,\r\n        trialDays: link.subscription.trialDays,\r\n        existingSubscriptionId: subscription?.id,\r\n        subscriptionStatus: subscription?.status,\r\n        nextPaymentDue: subscription?.nextPaymentDue.toISOString(),\r\n      };\r\n    }\r\n\r\n    if (this.config.signatureSecret) {\r\n      const data = JSON.stringify({ paymentLinkId: body.paymentLinkId, payment: body.payment, nonce });\r\n      body.signature = sign(data, this.config.signatureSecret);\r\n    }\r\n\r\n    res.set({\r\n      'Content-Type': 'application/json; charset=utf-8',\r\n      'X-PayPortal-Protocol': '402-v1',\r\n    });\r\n    res.status(402).json(body);\r\n  }\r\n\r\n  private send403(\r\n    res: Response,\r\n    code: ReasonCode,\r\n    paymentLinkId?: string,\r\n    details?: Record<string, unknown>\r\n  ): void {\r\n    const body: Protocol403Response = {\r\n      protocol: '403-payportal-v1',\r\n      paymentLinkId,\r\n      reasonCode: code,\r\n      reasonMessage: REASON_MESSAGES[code] ?? 'Forbidden',\r\n      details,\r\n    };\r\n\r\n    res.set({\r\n      'Content-Type': 'application/json; charset=utf-8',\r\n      'X-PayPortal-Protocol': '403-v1',\r\n    });\r\n    res.status(403).json(body);\r\n  }\r\n}\r\n\r\n/**\r\n * Create and start a payment portal server\r\n */\r\nexport function createServer(config: PortalConfig): PortalServer {\r\n  return new PortalServer(config);\r\n}\r\n","/**\r\n * Payment link status\r\n */\r\nexport type PaymentLinkStatus = 'active' | 'disabled' | 'expired';\r\n\r\n/**\r\n * Payment verification status\r\n */\r\nexport type PaymentStatus = 'not_found' | 'pending' | 'confirmed' | 'failed' | 'underpaid';\r\n\r\n/**\r\n * Subscription interval\r\n */\r\nexport type SubscriptionInterval = 'daily' | 'weekly' | 'monthly' | 'yearly';\r\n\r\n/**\r\n * Subscription status\r\n */\r\nexport type SubscriptionStatus = 'active' | 'past_due' | 'cancelled' | 'paused' | 'expired';\r\n\r\n/**\r\n * Chain type\r\n */\r\nexport type ChainType = 'evm' | 'solana';\r\n\r\n/**\r\n * Supported chain configuration\r\n */\r\nexport interface ChainConfig {\r\n  chainId: number;\r\n  name: string;\r\n  rpcUrl: string;\r\n  symbol: string;\r\n  confirmations?: number;\r\n  /** Chain type (default: 'evm') */\r\n  type?: ChainType;\r\n}\r\n\r\n/**\r\n * Solana chain IDs\r\n * 101 = Mainnet, 102 = Devnet, 103 = Testnet\r\n */\r\nexport const SOLANA_CHAIN_IDS = {\r\n  MAINNET: 101,\r\n  DEVNET: 102,\r\n  TESTNET: 103,\r\n} as const;\r\n\r\n/**\r\n * Price configuration (single currency - legacy)\r\n */\r\nexport interface Price {\r\n  amount: string;\r\n  tokenSymbol: string;\r\n  chainId: number;\r\n}\r\n\r\n/**\r\n * Payment option for multi-currency support\r\n */\r\nexport interface PaymentOption {\r\n  /** Token symbol (e.g., ETH, SOL, USDC) */\r\n  tokenSymbol: string;\r\n  /** Chain ID where payment is accepted */\r\n  chainId: number;\r\n  /** Amount in this token */\r\n  amount: string;\r\n  /** Recipient address for this payment option (optional, uses default if not set) */\r\n  recipientAddress?: string;\r\n}\r\n\r\n/**\r\n * Multi-currency price configuration\r\n */\r\nexport interface MultiPrice {\r\n  /** Default/primary price (used for display) */\r\n  primary: Price;\r\n  /** Additional accepted payment options */\r\n  options: PaymentOption[];\r\n}\r\n\r\n/**\r\n * Payment link entity\r\n */\r\nexport interface PaymentLink {\r\n  id: string;\r\n  targetUrl: string;\r\n  /** Primary price (for backward compatibility) */\r\n  price: Price;\r\n  /** Additional payment options for multi-currency */\r\n  paymentOptions?: PaymentOption[];\r\n  /** Default recipient address */\r\n  recipientAddress: string;\r\n  status: PaymentLinkStatus;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n  description?: string;\r\n  maxUses?: number;\r\n  usedCount?: number;\r\n  expiresAt?: Date;\r\n  metadata?: Record<string, unknown>;\r\n  /** Subscription configuration */\r\n  subscription?: SubscriptionConfig;\r\n}\r\n\r\n/**\r\n * Subscription configuration for a payment link\r\n */\r\nexport interface SubscriptionConfig {\r\n  /** Billing interval */\r\n  interval: SubscriptionInterval;\r\n  /** Number of intervals between billings (default: 1) */\r\n  intervalCount?: number;\r\n  /** Grace period in hours after due date before marking as past_due (default: 24) */\r\n  gracePeriodHours?: number;\r\n  /** Maximum number of billing cycles (undefined = unlimited) */\r\n  maxCycles?: number;\r\n  /** Trial period in days (0 = no trial) */\r\n  trialDays?: number;\r\n}\r\n\r\n/**\r\n * Subscription entity\r\n */\r\nexport interface Subscription {\r\n  id: string;\r\n  paymentLinkId: string;\r\n  subscriberAddress: string;\r\n  status: SubscriptionStatus;\r\n  currentPeriodStart: Date;\r\n  currentPeriodEnd: Date;\r\n  nextPaymentDue: Date;\r\n  cycleCount: number;\r\n  lastPaymentId?: string;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n  cancelledAt?: Date;\r\n  pausedAt?: Date;\r\n  trialEndsAt?: Date;\r\n  metadata?: Record<string, unknown>;\r\n}\r\n\r\n/**\r\n * Payment record\r\n */\r\nexport interface Payment {\r\n  id: string;\r\n  paymentLinkId: string;\r\n  chainId: number;\r\n  txHash: string;\r\n  fromAddress: string;\r\n  /** Amount paid */\r\n  amount: string;\r\n  /** Token symbol used for payment */\r\n  tokenSymbol?: string;\r\n  confirmed: boolean;\r\n  createdAt: Date;\r\n  confirmedAt?: Date;\r\n}\r\n\r\n/**\r\n * Input for creating a payment link\r\n */\r\nexport interface CreatePaymentLinkInput {\r\n  targetUrl: string;\r\n  /** Primary price */\r\n  price: Price;\r\n  /** Additional payment options for multi-currency */\r\n  paymentOptions?: PaymentOption[];\r\n  /** Default recipient address */\r\n  recipientAddress: string;\r\n  description?: string;\r\n  maxUses?: number;\r\n  expiresAt?: Date;\r\n  metadata?: Record<string, unknown>;\r\n  /** Subscription configuration (if set, creates a subscription link) */\r\n  subscription?: SubscriptionConfig;\r\n}\r\n\r\n/**\r\n * Input for creating a subscription\r\n */\r\nexport interface CreateSubscriptionInput {\r\n  paymentLinkId: string;\r\n  subscriberAddress: string;\r\n  metadata?: Record<string, unknown>;\r\n}\r\n\r\n/**\r\n * 402 Protocol response\r\n */\r\nexport interface Protocol402Response {\r\n  protocol: '402-payportal-v1';\r\n  paymentLinkId: string;\r\n  resource: {\r\n    description?: string;\r\n    preview?: string | null;\r\n  };\r\n  /** Primary payment option */\r\n  payment: {\r\n    chainId: number;\r\n    tokenSymbol: string;\r\n    amount: string;\r\n    recipient: string;\r\n    timeoutSeconds: number;\r\n  };\r\n  /** Additional payment options (multi-currency) */\r\n  paymentOptions?: Array<{\r\n    chainId: number;\r\n    tokenSymbol: string;\r\n    amount: string;\r\n    recipient: string;\r\n  }>;\r\n  callbacks: {\r\n    status: string;\r\n    confirm: string;\r\n  };\r\n  nonce: string;\r\n  signature?: string;\r\n  /** Subscription info (if this is a subscription link) */\r\n  subscription?: {\r\n    interval: SubscriptionInterval;\r\n    intervalCount: number;\r\n    trialDays?: number;\r\n    /** Existing subscription ID if subscriber already has one */\r\n    existingSubscriptionId?: string;\r\n    /** Current subscription status */\r\n    subscriptionStatus?: SubscriptionStatus;\r\n    /** Next payment due date */\r\n    nextPaymentDue?: string;\r\n  };\r\n}\r\n\r\n/**\r\n * 403 Reason codes\r\n */\r\nexport enum ReasonCode {\r\n  LINK_NOT_FOUND = 'LINK_NOT_FOUND',\r\n  LINK_DISABLED = 'LINK_DISABLED',\r\n  LINK_EXPIRED = 'LINK_EXPIRED',\r\n  LINK_USAGE_LIMIT_REACHED = 'LINK_USAGE_LIMIT_REACHED',\r\n  PAYMENT_UNDERPAID = 'PAYMENT_UNDERPAID',\r\n  PAYMENT_CHAIN_NOT_SUPPORTED = 'PAYMENT_CHAIN_NOT_SUPPORTED',\r\n  ACCESS_DENIED = 'ACCESS_DENIED',\r\n  INTERNAL_ERROR = 'INTERNAL_ERROR',\r\n  SUBSCRIPTION_CANCELLED = 'SUBSCRIPTION_CANCELLED',\r\n  SUBSCRIPTION_PAST_DUE = 'SUBSCRIPTION_PAST_DUE',\r\n  SUBSCRIPTION_PAUSED = 'SUBSCRIPTION_PAUSED',\r\n  SUBSCRIPTION_EXPIRED = 'SUBSCRIPTION_EXPIRED',\r\n  SUBSCRIPTION_MAX_CYCLES_REACHED = 'SUBSCRIPTION_MAX_CYCLES_REACHED',\r\n}\r\n\r\n/**\r\n * 403 Protocol response\r\n */\r\nexport interface Protocol403Response {\r\n  protocol: '403-payportal-v1';\r\n  paymentLinkId?: string;\r\n  reasonCode: ReasonCode;\r\n  reasonMessage: string;\r\n  details?: Record<string, unknown>;\r\n}\r\n\r\n/**\r\n * Webhook configuration\r\n */\r\nexport interface WebhookConfigType {\r\n  /** Webhook URL to send events to */\r\n  url: string;\r\n  /** Secret for HMAC signature */\r\n  secret?: string;\r\n  /** Events to send */\r\n  events?: Array<\r\n    | 'payment.confirmed'\r\n    | 'payment.pending'\r\n    | 'payment.failed'\r\n    | 'payment.underpaid'\r\n    | 'link.created'\r\n    | 'link.disabled'\r\n    | 'subscription.created'\r\n    | 'subscription.renewed'\r\n    | 'subscription.cancelled'\r\n    | 'subscription.paused'\r\n    | 'subscription.resumed'\r\n    | 'subscription.past_due'\r\n    | 'subscription.expired'\r\n    | 'subscription.trial_ending'\r\n    | 'subscription.payment_due'\r\n  >;\r\n  /** Request timeout in ms */\r\n  timeout?: number;\r\n  /** Retry count on failure */\r\n  retries?: number;\r\n}\r\n\r\n/**\r\n * Portal token configuration ($PP)\r\n */\r\nexport interface PortalTokenConfigType {\r\n  /** Enable $PP token payments */\r\n  enabled?: boolean;\r\n  /** Discount when paying with $PP token (percentage, 0-100) */\r\n  paymentDiscount?: number;\r\n  /** Enable holder discounts based on $PP balance */\r\n  holderDiscounts?: boolean;\r\n  /** Custom discount tiers */\r\n  discountTiers?: Array<{\r\n    minBalance: number;\r\n    discountPercent: number;\r\n    name: string;\r\n  }>;\r\n}\r\n\r\n/**\r\n * Server configuration\r\n */\r\nexport interface PortalConfig {\r\n  /** Server port */\r\n  port?: number;\r\n  /** Base URL for callbacks (e.g., https://your-domain.com) */\r\n  baseUrl?: string;\r\n  /** Base path for payment portal routes (default: /pay) */\r\n  basePath?: string;\r\n  /** Supported blockchain networks */\r\n  chains: ChainConfig[];\r\n  /** Payment timeout in seconds (default: 900) */\r\n  paymentTimeout?: number;\r\n  /** Secret for signing responses */\r\n  signatureSecret?: string;\r\n  /** API key for admin endpoints */\r\n  apiKey?: string;\r\n  /** Enable CORS (default: true) */\r\n  cors?: boolean;\r\n  /** Webhook configuration */\r\n  webhook?: WebhookConfigType;\r\n  /** Portal token configuration ($PP) */\r\n  portalToken?: PortalTokenConfigType;\r\n}\r\n\r\n/**\r\n * Payment check result\r\n */\r\nexport interface PaymentCheckResult {\r\n  status: PaymentStatus;\r\n  actualAmount?: string;\r\n  fromAddress?: string;\r\n  raw?: unknown;\r\n}\r\n\r\n/**\r\n * Payment status result (alias for PaymentCheckResult)\r\n */\r\nexport type PaymentStatusResult = PaymentCheckResult;\r\n\r\n/**\r\n * Payment provider interface\r\n */\r\nexport interface PaymentProvider {\r\n  getPaymentStatus(params: {\r\n    chainId: number;\r\n    recipient: string;\r\n    amount: string;\r\n    txHash?: string;\r\n  }): Promise<PaymentStatusResult>;\r\n}\r\n\r\n/**\r\n * Storage interface\r\n */\r\nexport interface Storage {\r\n  getPaymentLink(id: string): Promise<PaymentLink | null>;\r\n  savePaymentLink(paymentLink: PaymentLink): Promise<void>;\r\n  updatePaymentLink(paymentLink: PaymentLink): Promise<void>;\r\n  deletePaymentLink(id: string): Promise<void>;\r\n  getAllPaymentLinks(): Promise<PaymentLink[]>;\r\n  \r\n  savePayment(payment: Payment): Promise<void>;\r\n  getPaymentByTxHash(txHash: string): Promise<Payment | null>;\r\n  getConfirmedPayment(paymentLinkId: string): Promise<Payment | null>;\r\n  getAllPayments(): Promise<Payment[]>;\r\n\r\n  // Subscription methods\r\n  saveSubscription(subscription: Subscription): Promise<void>;\r\n  getSubscription(id: string): Promise<Subscription | null>;\r\n  updateSubscription(subscription: Subscription): Promise<void>;\r\n  getSubscriptionByAddress(paymentLinkId: string, subscriberAddress: string): Promise<Subscription | null>;\r\n  getSubscriptionsByPaymentLink(paymentLinkId: string): Promise<Subscription[]>;\r\n  getSubscriptionsDue(beforeDate: Date): Promise<Subscription[]>;\r\n  getAllSubscriptions(): Promise<Subscription[]>;\r\n}\r\n","import type { Storage, PaymentLink, Payment, Subscription } from './types.js';\r\n\r\n/**\r\n * In-memory storage implementation\r\n * Replace with database for production\r\n */\r\nexport class MemoryStorage implements Storage {\r\n  private links = new Map<string, PaymentLink>();\r\n  private payments = new Map<string, Payment>();\r\n  private paymentsByTx = new Map<string, Payment>();\r\n  private paymentsByLink = new Map<string, Payment[]>();\r\n  private subscriptions = new Map<string, Subscription>();\r\n  private subscriptionsByAddress = new Map<string, Subscription>();\r\n  private subscriptionsByLink = new Map<string, Subscription[]>();\r\n\r\n  async getPaymentLink(id: string): Promise<PaymentLink | null> {\r\n    return this.links.get(id) ?? null;\r\n  }\r\n\r\n  async savePaymentLink(paymentLink: PaymentLink): Promise<void> {\r\n    this.links.set(paymentLink.id, { ...paymentLink });\r\n  }\r\n\r\n  async updatePaymentLink(paymentLink: PaymentLink): Promise<void> {\r\n    if (!this.links.has(paymentLink.id)) {\r\n      throw new Error(`Payment link ${paymentLink.id} not found`);\r\n    }\r\n    this.links.set(paymentLink.id, { ...paymentLink, updatedAt: new Date() });\r\n  }\r\n\r\n  async deletePaymentLink(id: string): Promise<void> {\r\n    this.links.delete(id);\r\n  }\r\n\r\n  async getAllPaymentLinks(): Promise<PaymentLink[]> {\r\n    return Array.from(this.links.values());\r\n  }\r\n\r\n  async savePayment(payment: Payment): Promise<void> {\r\n    this.payments.set(payment.id, { ...payment });\r\n    this.paymentsByTx.set(payment.txHash, payment);\r\n    \r\n    const list = this.paymentsByLink.get(payment.paymentLinkId) ?? [];\r\n    list.push(payment);\r\n    this.paymentsByLink.set(payment.paymentLinkId, list);\r\n  }\r\n\r\n  async getPaymentByTxHash(txHash: string): Promise<Payment | null> {\r\n    return this.paymentsByTx.get(txHash) ?? null;\r\n  }\r\n\r\n  async getConfirmedPayment(paymentLinkId: string): Promise<Payment | null> {\r\n    const list = this.paymentsByLink.get(paymentLinkId) ?? [];\r\n    return list.find(p => p.confirmed) ?? null;\r\n  }\r\n\r\n  async getAllPayments(): Promise<Payment[]> {\r\n    return Array.from(this.payments.values());\r\n  }\r\n\r\n  // Subscription methods\r\n\r\n  async saveSubscription(subscription: Subscription): Promise<void> {\r\n    this.subscriptions.set(subscription.id, { ...subscription });\r\n    \r\n    // Index by address\r\n    const addressKey = `${subscription.paymentLinkId}:${subscription.subscriberAddress}`;\r\n    this.subscriptionsByAddress.set(addressKey, subscription);\r\n    \r\n    // Index by link\r\n    const linkSubs = this.subscriptionsByLink.get(subscription.paymentLinkId) ?? [];\r\n    linkSubs.push(subscription);\r\n    this.subscriptionsByLink.set(subscription.paymentLinkId, linkSubs);\r\n  }\r\n\r\n  async getSubscription(id: string): Promise<Subscription | null> {\r\n    return this.subscriptions.get(id) ?? null;\r\n  }\r\n\r\n  async updateSubscription(subscription: Subscription): Promise<void> {\r\n    if (!this.subscriptions.has(subscription.id)) {\r\n      throw new Error(`Subscription ${subscription.id} not found`);\r\n    }\r\n    \r\n    const updated = { ...subscription, updatedAt: new Date() };\r\n    this.subscriptions.set(subscription.id, updated);\r\n    \r\n    // Update address index\r\n    const addressKey = `${subscription.paymentLinkId}:${subscription.subscriberAddress}`;\r\n    this.subscriptionsByAddress.set(addressKey, updated);\r\n    \r\n    // Update link index\r\n    const linkSubs = this.subscriptionsByLink.get(subscription.paymentLinkId) ?? [];\r\n    const idx = linkSubs.findIndex(s => s.id === subscription.id);\r\n    if (idx !== -1) {\r\n      linkSubs[idx] = updated;\r\n    }\r\n  }\r\n\r\n  async getSubscriptionByAddress(\r\n    paymentLinkId: string,\r\n    subscriberAddress: string\r\n  ): Promise<Subscription | null> {\r\n    const addressKey = `${paymentLinkId}:${subscriberAddress}`;\r\n    return this.subscriptionsByAddress.get(addressKey) ?? null;\r\n  }\r\n\r\n  async getSubscriptionsByPaymentLink(paymentLinkId: string): Promise<Subscription[]> {\r\n    return this.subscriptionsByLink.get(paymentLinkId) ?? [];\r\n  }\r\n\r\n  async getSubscriptionsDue(beforeDate: Date): Promise<Subscription[]> {\r\n    const result: Subscription[] = [];\r\n    for (const sub of this.subscriptions.values()) {\r\n      if (\r\n        sub.status === 'active' &&\r\n        sub.nextPaymentDue <= beforeDate\r\n      ) {\r\n        result.push(sub);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  async getAllSubscriptions(): Promise<Subscription[]> {\r\n    return Array.from(this.subscriptions.values());\r\n  }\r\n\r\n  /** Clear all data */\r\n  clear(): void {\r\n    this.links.clear();\r\n    this.payments.clear();\r\n    this.paymentsByTx.clear();\r\n    this.paymentsByLink.clear();\r\n    this.subscriptions.clear();\r\n    this.subscriptionsByAddress.clear();\r\n    this.subscriptionsByLink.clear();\r\n  }\r\n}\r\n","import { randomBytes, createHmac, randomUUID } from 'crypto';\r\n\r\n/**\r\n * Generate short unique ID\r\n */\r\nexport function generateId(length = 8): string {\r\n  const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\r\n  const bytes = randomBytes(length);\r\n  let result = '';\r\n  for (let i = 0; i < length; i++) {\r\n    result += chars[bytes[i] % chars.length];\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Generate UUID\r\n */\r\nexport function generateUUID(): string {\r\n  return randomUUID();\r\n}\r\n\r\n/**\r\n * Generate nonce\r\n */\r\nexport function generateNonce(): string {\r\n  return randomBytes(16).toString('hex');\r\n}\r\n\r\n/**\r\n * Create HMAC signature\r\n */\r\nexport function sign(data: string, secret: string): string {\r\n  return createHmac('sha256', secret).update(data).digest('hex');\r\n}\r\n\r\n/**\r\n * Create signature (alias for sign)\r\n */\r\nexport const createSignature = sign;\r\n\r\n/**\r\n * Check if date is expired\r\n */\r\nexport function isExpired(date?: Date): boolean {\r\n  if (!date) return false;\r\n  return new Date() > new Date(date);\r\n}\r\n\r\n/**\r\n * Check if usage limit reached\r\n */\r\nexport function isLimitReached(used?: number, max?: number): boolean {\r\n  if (max === undefined) return false;\r\n  return (used ?? 0) >= max;\r\n}\r\n\r\n/**\r\n * Compare amounts\r\n */\r\nexport function compareAmounts(a: string, b: string): number {\r\n  const numA = parseFloat(a);\r\n  const numB = parseFloat(b);\r\n  if (numA < numB) return -1;\r\n  if (numA > numB) return 1;\r\n  return 0;\r\n}\r\n\r\n/**\r\n * Reason code messages\r\n */\r\nexport const REASON_MESSAGES: Record<string, string> = {\r\n  LINK_NOT_FOUND: 'Payment link not found.',\r\n  LINK_DISABLED: 'This payment link has been disabled.',\r\n  LINK_EXPIRED: 'This payment link has expired.',\r\n  LINK_USAGE_LIMIT_REACHED: 'This payment link has reached its usage limit.',\r\n  PAYMENT_UNDERPAID: 'Payment amount is less than required.',\r\n  PAYMENT_CHAIN_NOT_SUPPORTED: 'This blockchain is not supported.',\r\n  ACCESS_DENIED: 'Access denied.',\r\n  INTERNAL_ERROR: 'An internal error occurred.',\r\n  SUBSCRIPTION_CANCELLED: 'This subscription has been cancelled.',\r\n  SUBSCRIPTION_PAST_DUE: 'Subscription payment is past due.',\r\n  SUBSCRIPTION_PAUSED: 'This subscription is paused.',\r\n  SUBSCRIPTION_EXPIRED: 'This subscription has expired.',\r\n  SUBSCRIPTION_MAX_CYCLES_REACHED: 'Subscription has reached maximum billing cycles.',\r\n};\r\n","import type { ChainConfig, PaymentCheckResult } from './types.js';\r\nimport { compareAmounts } from './utils.js';\r\n\r\n/**\r\n * Blockchain payment verifier\r\n */\r\nexport class ChainVerifier {\r\n  private config: ChainConfig;\r\n  private requestId = 0;\r\n\r\n  constructor(config: ChainConfig) {\r\n    this.config = config;\r\n  }\r\n\r\n  get chainId(): number {\r\n    return this.config.chainId;\r\n  }\r\n\r\n  /**\r\n   * Verify payment on chain\r\n   */\r\n  async verifyPayment(params: {\r\n    txHash: string;\r\n    recipient: string;\r\n    amount: string;\r\n  }): Promise<PaymentCheckResult> {\r\n    try {\r\n      // Get transaction\r\n      const tx = await this.rpc('eth_getTransactionByHash', [params.txHash]);\r\n      \r\n      if (!tx) {\r\n        return { status: 'not_found' };\r\n      }\r\n\r\n      // Not mined yet\r\n      if (!tx.blockNumber) {\r\n        return { status: 'pending' };\r\n      }\r\n\r\n      // Get receipt\r\n      const receipt = await this.rpc('eth_getTransactionReceipt', [params.txHash]);\r\n      \r\n      if (!receipt) {\r\n        return { status: 'pending' };\r\n      }\r\n\r\n      // Failed transaction\r\n      if (receipt.status === '0x0') {\r\n        return { status: 'failed' };\r\n      }\r\n\r\n      // Check confirmations\r\n      const currentBlock = await this.rpc('eth_blockNumber', []);\r\n      const txBlock = parseInt(tx.blockNumber, 16);\r\n      const current = parseInt(currentBlock, 16);\r\n      const confirmations = current - txBlock;\r\n\r\n      if (confirmations < (this.config.confirmations ?? 1)) {\r\n        return { status: 'pending' };\r\n      }\r\n\r\n      // Verify recipient\r\n      const recipientLower = params.recipient.toLowerCase();\r\n      const toAddress = (tx.to || '').toLowerCase();\r\n      \r\n      if (toAddress !== recipientLower) {\r\n        // Check if it's a token transfer\r\n        if (!this.isTokenTransfer(receipt, recipientLower)) {\r\n          return { status: 'not_found' };\r\n        }\r\n      }\r\n\r\n      // Calculate amount\r\n      const valueWei = BigInt(tx.value || '0');\r\n      const actualAmount = this.weiToEther(valueWei);\r\n\r\n      // Check amount\r\n      if (compareAmounts(actualAmount, params.amount) < 0) {\r\n        return {\r\n          status: 'underpaid',\r\n          actualAmount,\r\n          fromAddress: tx.from,\r\n        };\r\n      }\r\n\r\n      return {\r\n        status: 'confirmed',\r\n        actualAmount,\r\n        fromAddress: tx.from,\r\n        raw: { tx, receipt },\r\n      };\r\n    } catch (error) {\r\n      console.error(`Chain ${this.config.chainId} verification error:`, error);\r\n      return { status: 'not_found' };\r\n    }\r\n  }\r\n\r\n  private async rpc(method: string, params: unknown[]): Promise<any> {\r\n    const controller = new AbortController();\r\n    const timeout = setTimeout(() => controller.abort(), 30000);\r\n\r\n    try {\r\n      const response = await fetch(this.config.rpcUrl, {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify({\r\n          jsonrpc: '2.0',\r\n          id: ++this.requestId,\r\n          method,\r\n          params,\r\n        }),\r\n        signal: controller.signal,\r\n      });\r\n\r\n      const data = await response.json() as { error?: { message: string }; result?: unknown };\r\n      \r\n      if (data.error) {\r\n        throw new Error(data.error.message);\r\n      }\r\n      \r\n      return data.result;\r\n    } finally {\r\n      clearTimeout(timeout);\r\n    }\r\n  }\r\n\r\n  private isTokenTransfer(receipt: any, recipient: string): boolean {\r\n    // ERC20 Transfer event signature\r\n    const transferTopic = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef';\r\n    \r\n    for (const log of receipt.logs || []) {\r\n      if (log.topics?.[0] === transferTopic && log.topics.length >= 3) {\r\n        const to = '0x' + log.topics[2].slice(26).toLowerCase();\r\n        if (to === recipient) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    \r\n    return false;\r\n  }\r\n\r\n  private weiToEther(wei: bigint): string {\r\n    return (Number(wei) / 1e18).toString();\r\n  }\r\n}\r\n\r\n/**\r\n * Mock verifier for development/testing\r\n */\r\nexport class MockVerifier {\r\n  private confirmed = new Set<string>();\r\n  private pending = new Set<string>();\r\n  private failed = new Set<string>();\r\n\r\n  chainId = 1;\r\n\r\n  markConfirmed(txHash: string): void {\r\n    this.confirmed.add(txHash);\r\n    this.pending.delete(txHash);\r\n    this.failed.delete(txHash);\r\n  }\r\n\r\n  markPending(txHash: string): void {\r\n    this.pending.add(txHash);\r\n  }\r\n\r\n  markFailed(txHash: string): void {\r\n    this.failed.add(txHash);\r\n  }\r\n\r\n  async verifyPayment(params: {\r\n    txHash: string;\r\n    recipient: string;\r\n    amount: string;\r\n  }): Promise<PaymentCheckResult> {\r\n    await new Promise(r => setTimeout(r, 100));\r\n\r\n    if (this.failed.has(params.txHash)) {\r\n      return { status: 'failed' };\r\n    }\r\n\r\n    if (this.pending.has(params.txHash)) {\r\n      return { status: 'pending' };\r\n    }\r\n\r\n    // Auto-confirm for testing\r\n    return {\r\n      status: 'confirmed',\r\n      actualAmount: params.amount,\r\n      fromAddress: '0x' + 'a'.repeat(40),\r\n    };\r\n  }\r\n}\r\n","import type { PaymentCheckResult } from '../types.js';\r\nimport { compareAmounts } from '../utils.js';\r\n\r\n/**\r\n * Solana chain configuration\r\n */\r\nexport interface SolanaConfig {\r\n  /** RPC URL (e.g., https://api.mainnet-beta.solana.com) */\r\n  rpcUrl: string;\r\n  /** Number of confirmations required (default: 1) */\r\n  confirmations?: number;\r\n  /** Request timeout in ms (default: 30000) */\r\n  timeout?: number;\r\n}\r\n\r\ninterface JsonRpcResponse<T> {\r\n  jsonrpc: string;\r\n  id: number;\r\n  result?: T;\r\n  error?: {\r\n    code: number;\r\n    message: string;\r\n  };\r\n}\r\n\r\ninterface SolanaTransaction {\r\n  slot: number;\r\n  meta: {\r\n    err: null | object;\r\n    fee: number;\r\n    preBalances: number[];\r\n    postBalances: number[];\r\n    status: { Ok: null } | { Err: object };\r\n  } | null;\r\n  transaction: {\r\n    message: {\r\n      accountKeys: string[];\r\n      instructions: Array<{\r\n        programIdIndex: number;\r\n        accounts: number[];\r\n        data: string;\r\n      }>;\r\n    };\r\n    signatures: string[];\r\n  };\r\n  blockTime: number | null;\r\n}\r\n\r\ninterface SignatureStatus {\r\n  slot: number;\r\n  confirmations: number | null;\r\n  err: null | object;\r\n  confirmationStatus: 'processed' | 'confirmed' | 'finalized' | null;\r\n}\r\n\r\n/**\r\n * Solana Payment Verifier\r\n * Verifies native SOL transfers on Solana blockchain\r\n */\r\nexport class SolanaVerifier {\r\n  private config: Required<SolanaConfig>;\r\n  private requestId = 0;\r\n\r\n  constructor(config: SolanaConfig) {\r\n    this.config = {\r\n      rpcUrl: config.rpcUrl,\r\n      confirmations: config.confirmations ?? 1,\r\n      timeout: config.timeout ?? 30000,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Verify a Solana payment\r\n   */\r\n  async verifyPayment(params: {\r\n    txHash: string;\r\n    recipient: string;\r\n    amount: string;\r\n  }): Promise<PaymentCheckResult> {\r\n    try {\r\n      // Get transaction details\r\n      const tx = await this.getTransaction(params.txHash);\r\n\r\n      if (!tx) {\r\n        return { status: 'not_found' };\r\n      }\r\n\r\n      // Check if transaction failed\r\n      if (tx.meta?.err) {\r\n        return { status: 'failed' };\r\n      }\r\n\r\n      // Get signature status for confirmation count\r\n      const status = await this.getSignatureStatus(params.txHash);\r\n\r\n      if (!status) {\r\n        return { status: 'pending' };\r\n      }\r\n\r\n      // Check confirmations\r\n      const confirmations = status.confirmations ?? 0;\r\n      const isFinalized = status.confirmationStatus === 'finalized';\r\n\r\n      if (!isFinalized && confirmations < this.config.confirmations) {\r\n        return { status: 'pending' };\r\n      }\r\n\r\n      // Parse transaction to find recipient and amount\r\n      const { recipient: actualRecipient, amount: actualAmount, sender } = \r\n        this.parseTransfer(tx, params.recipient);\r\n\r\n      if (!actualRecipient) {\r\n        return { status: 'not_found' };\r\n      }\r\n\r\n      // Verify recipient matches\r\n      if (actualRecipient.toLowerCase() !== params.recipient.toLowerCase()) {\r\n        return { status: 'not_found' };\r\n      }\r\n\r\n      // Compare amounts (SOL has 9 decimals)\r\n      if (compareAmounts(actualAmount, params.amount) < 0) {\r\n        return {\r\n          status: 'underpaid',\r\n          actualAmount,\r\n          fromAddress: sender,\r\n          raw: tx,\r\n        };\r\n      }\r\n\r\n      return {\r\n        status: 'confirmed',\r\n        actualAmount,\r\n        fromAddress: sender,\r\n        raw: tx,\r\n      };\r\n    } catch (error) {\r\n      console.error('Solana verification error:', error);\r\n      return { status: 'not_found' };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parse a Solana transaction to extract transfer details\r\n   */\r\n  private parseTransfer(\r\n    tx: SolanaTransaction,\r\n    expectedRecipient: string\r\n  ): { recipient: string | null; amount: string; sender: string } {\r\n    const accountKeys = tx.transaction.message.accountKeys;\r\n    const preBalances = tx.meta?.preBalances ?? [];\r\n    const postBalances = tx.meta?.postBalances ?? [];\r\n\r\n    // Find the expected recipient in account keys\r\n    const recipientIndex = accountKeys.findIndex(\r\n      key => key.toLowerCase() === expectedRecipient.toLowerCase()\r\n    );\r\n\r\n    if (recipientIndex === -1) {\r\n      return { recipient: null, amount: '0', sender: '' };\r\n    }\r\n\r\n    // Calculate amount received (in lamports)\r\n    const preBalance = preBalances[recipientIndex] ?? 0;\r\n    const postBalance = postBalances[recipientIndex] ?? 0;\r\n    const lamportsReceived = postBalance - preBalance;\r\n\r\n    if (lamportsReceived <= 0) {\r\n      return { recipient: null, amount: '0', sender: '' };\r\n    }\r\n\r\n    // Convert lamports to SOL (9 decimals)\r\n    const solAmount = lamportsReceived / 1e9;\r\n\r\n    // First account is typically the fee payer/sender\r\n    const sender = accountKeys[0] ?? '';\r\n\r\n    return {\r\n      recipient: expectedRecipient,\r\n      amount: solAmount.toString(),\r\n      sender,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get transaction details from Solana RPC\r\n   */\r\n  private async getTransaction(signature: string): Promise<SolanaTransaction | null> {\r\n    return this.rpc<SolanaTransaction>('getTransaction', [\r\n      signature,\r\n      {\r\n        encoding: 'json',\r\n        commitment: 'confirmed',\r\n        maxSupportedTransactionVersion: 0,\r\n      },\r\n    ]);\r\n  }\r\n\r\n  /**\r\n   * Get signature status\r\n   */\r\n  private async getSignatureStatus(signature: string): Promise<SignatureStatus | null> {\r\n    const result = await this.rpc<{ value: Array<SignatureStatus | null> }>(\r\n      'getSignatureStatuses',\r\n      [[signature]]\r\n    );\r\n    return result?.value?.[0] ?? null;\r\n  }\r\n\r\n  /**\r\n   * Make an RPC call to Solana\r\n   */\r\n  private async rpc<T>(method: string, params: unknown[]): Promise<T | null> {\r\n    const controller = new AbortController();\r\n    const timeout = setTimeout(() => controller.abort(), this.config.timeout);\r\n\r\n    try {\r\n      const response = await fetch(this.config.rpcUrl, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify({\r\n          jsonrpc: '2.0',\r\n          id: ++this.requestId,\r\n          method,\r\n          params,\r\n        }),\r\n        signal: controller.signal,\r\n      });\r\n\r\n      const data = (await response.json()) as JsonRpcResponse<T>;\r\n\r\n      if (data.error) {\r\n        console.error('Solana RPC error:', data.error);\r\n        return null;\r\n      }\r\n\r\n      return data.result ?? null;\r\n    } catch (error) {\r\n      if ((error as Error).name === 'AbortError') {\r\n        console.error('Solana RPC request timeout');\r\n      } else {\r\n        console.error('Solana RPC error:', error);\r\n      }\r\n      return null;\r\n    } finally {\r\n      clearTimeout(timeout);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Mock Solana verifier for testing\r\n */\r\nexport class MockSolanaVerifier {\r\n  private confirmed = new Set<string>();\r\n  private pending = new Set<string>();\r\n  private failed = new Set<string>();\r\n\r\n  markConfirmed(signature: string): void {\r\n    this.confirmed.add(signature);\r\n    this.pending.delete(signature);\r\n    this.failed.delete(signature);\r\n  }\r\n\r\n  markPending(signature: string): void {\r\n    this.pending.add(signature);\r\n  }\r\n\r\n  markFailed(signature: string): void {\r\n    this.failed.add(signature);\r\n  }\r\n\r\n  async verifyPayment(params: {\r\n    txHash: string;\r\n    recipient: string;\r\n    amount: string;\r\n  }): Promise<PaymentCheckResult> {\r\n    await new Promise(r => setTimeout(r, 100));\r\n\r\n    if (this.failed.has(params.txHash)) {\r\n      return { status: 'failed' };\r\n    }\r\n\r\n    if (this.pending.has(params.txHash)) {\r\n      return { status: 'pending' };\r\n    }\r\n\r\n    // Auto-confirm for testing\r\n    return {\r\n      status: 'confirmed',\r\n      actualAmount: params.amount,\r\n      fromAddress: 'So11111111111111111111111111111111111111112',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Create a Solana verifier\r\n */\r\nexport function createSolanaVerifier(config: SolanaConfig): SolanaVerifier {\r\n  return new SolanaVerifier(config);\r\n}\r\n","import { createHmac } from 'crypto';\r\nimport type { PaymentLink, Payment, Subscription } from './types.js';\r\n\r\n/**\r\n * Webhook configuration\r\n */\r\nexport interface WebhookConfig {\r\n  /** Webhook URL to send events to */\r\n  url: string;\r\n  /** Secret for HMAC signature */\r\n  secret?: string;\r\n  /** Events to send (default: all) */\r\n  events?: WebhookEvent[];\r\n  /** Request timeout in ms (default: 10000) */\r\n  timeout?: number;\r\n  /** Retry count on failure (default: 3) */\r\n  retries?: number;\r\n  /** Custom headers to include */\r\n  headers?: Record<string, string>;\r\n}\r\n\r\n/**\r\n * Webhook event types\r\n */\r\nexport type WebhookEvent =\r\n  | 'payment.confirmed'\r\n  | 'payment.pending'\r\n  | 'payment.failed'\r\n  | 'payment.underpaid'\r\n  | 'link.created'\r\n  | 'link.disabled'\r\n  | 'link.expired'\r\n  | 'subscription.created'\r\n  | 'subscription.renewed'\r\n  | 'subscription.cancelled'\r\n  | 'subscription.paused'\r\n  | 'subscription.resumed'\r\n  | 'subscription.past_due'\r\n  | 'subscription.expired'\r\n  | 'subscription.trial_ending'\r\n  | 'subscription.payment_due';\r\n\r\n/**\r\n * Webhook payload base\r\n */\r\nexport interface WebhookPayload {\r\n  /** Event type */\r\n  event: WebhookEvent;\r\n  /** Event timestamp */\r\n  timestamp: string;\r\n  /** Unique event ID */\r\n  eventId: string;\r\n  /** Event data */\r\n  data: WebhookPaymentData | WebhookLinkData | WebhookSubscriptionData;\r\n}\r\n\r\n/**\r\n * Payment event data\r\n */\r\nexport interface WebhookPaymentData {\r\n  type: 'payment';\r\n  payment: {\r\n    id: string;\r\n    paymentLinkId: string;\r\n    chainId: number;\r\n    txHash: string;\r\n    fromAddress: string;\r\n    amount: string;\r\n    confirmed: boolean;\r\n    createdAt: string;\r\n    confirmedAt?: string;\r\n  };\r\n  paymentLink: {\r\n    id: string;\r\n    targetUrl: string;\r\n    price: {\r\n      amount: string;\r\n      tokenSymbol: string;\r\n      chainId: number;\r\n    };\r\n    recipientAddress: string;\r\n  };\r\n}\r\n\r\n/**\r\n * Link event data\r\n */\r\nexport interface WebhookLinkData {\r\n  type: 'link';\r\n  link: {\r\n    id: string;\r\n    targetUrl: string;\r\n    price: {\r\n      amount: string;\r\n      tokenSymbol: string;\r\n      chainId: number;\r\n    };\r\n    recipientAddress: string;\r\n    status: string;\r\n    createdAt: string;\r\n    description?: string;\r\n    maxUses?: number;\r\n    expiresAt?: string;\r\n  };\r\n}\r\n\r\n/**\r\n * Subscription event data\r\n */\r\nexport interface WebhookSubscriptionData {\r\n  type: 'subscription';\r\n  subscription: {\r\n    id: string;\r\n    paymentLinkId: string;\r\n    subscriberAddress: string;\r\n    status: string;\r\n    currentPeriodStart: string;\r\n    currentPeriodEnd: string;\r\n    nextPaymentDue: string;\r\n    cycleCount: number;\r\n    createdAt: string;\r\n    cancelledAt?: string;\r\n    pausedAt?: string;\r\n    trialEndsAt?: string;\r\n  };\r\n  paymentLink: {\r\n    id: string;\r\n    targetUrl: string;\r\n    price: {\r\n      amount: string;\r\n      tokenSymbol: string;\r\n      chainId: number;\r\n    };\r\n    recipientAddress: string;\r\n    subscription?: {\r\n      interval: string;\r\n      intervalCount?: number;\r\n    };\r\n  };\r\n}\r\n\r\n/**\r\n * Webhook delivery result\r\n */\r\nexport interface WebhookResult {\r\n  success: boolean;\r\n  statusCode?: number;\r\n  error?: string;\r\n  attempts: number;\r\n  duration: number;\r\n}\r\n\r\n/**\r\n * Webhook Manager\r\n * Handles sending webhook notifications for payment events\r\n */\r\nexport class WebhookManager {\r\n  private config: Required<Omit<WebhookConfig, 'secret' | 'headers'>> & {\r\n    secret?: string;\r\n    headers?: Record<string, string>;\r\n  };\r\n  private queue: Array<{ payload: WebhookPayload; attempt: number }> = [];\r\n  private processing = false;\r\n\r\n  constructor(config: WebhookConfig) {\r\n    this.config = {\r\n      url: config.url,\r\n      secret: config.secret,\r\n      events: config.events ?? [\r\n        'payment.confirmed',\r\n        'payment.pending',\r\n        'payment.failed',\r\n        'payment.underpaid',\r\n        'link.created',\r\n        'link.disabled',\r\n        'subscription.created',\r\n        'subscription.renewed',\r\n        'subscription.cancelled',\r\n        'subscription.paused',\r\n        'subscription.resumed',\r\n        'subscription.past_due',\r\n        'subscription.expired',\r\n        'subscription.trial_ending',\r\n        'subscription.payment_due',\r\n      ],\r\n      timeout: config.timeout ?? 10000,\r\n      retries: config.retries ?? 3,\r\n      headers: config.headers,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Check if event type is enabled\r\n   */\r\n  isEventEnabled(event: WebhookEvent): boolean {\r\n    return this.config.events.includes(event);\r\n  }\r\n\r\n  /**\r\n   * Send payment event\r\n   */\r\n  async sendPaymentEvent(\r\n    event: WebhookEvent,\r\n    payment: Payment,\r\n    paymentLink: PaymentLink\r\n  ): Promise<WebhookResult | null> {\r\n    if (!this.isEventEnabled(event)) {\r\n      return null;\r\n    }\r\n\r\n    const payload: WebhookPayload = {\r\n      event,\r\n      timestamp: new Date().toISOString(),\r\n      eventId: this.generateEventId(),\r\n      data: {\r\n        type: 'payment',\r\n        payment: {\r\n          id: payment.id,\r\n          paymentLinkId: payment.paymentLinkId,\r\n          chainId: payment.chainId,\r\n          txHash: payment.txHash,\r\n          fromAddress: payment.fromAddress,\r\n          amount: payment.amount,\r\n          confirmed: payment.confirmed,\r\n          createdAt: payment.createdAt.toISOString(),\r\n          confirmedAt: payment.confirmedAt?.toISOString(),\r\n        },\r\n        paymentLink: {\r\n          id: paymentLink.id,\r\n          targetUrl: paymentLink.targetUrl,\r\n          price: paymentLink.price,\r\n          recipientAddress: paymentLink.recipientAddress,\r\n        },\r\n      },\r\n    };\r\n\r\n    return this.send(payload);\r\n  }\r\n\r\n  /**\r\n   * Send link event\r\n   */\r\n  async sendLinkEvent(\r\n    event: WebhookEvent,\r\n    paymentLink: PaymentLink\r\n  ): Promise<WebhookResult | null> {\r\n    if (!this.isEventEnabled(event)) {\r\n      return null;\r\n    }\r\n\r\n    const payload: WebhookPayload = {\r\n      event,\r\n      timestamp: new Date().toISOString(),\r\n      eventId: this.generateEventId(),\r\n      data: {\r\n        type: 'link',\r\n        link: {\r\n          id: paymentLink.id,\r\n          targetUrl: paymentLink.targetUrl,\r\n          price: paymentLink.price,\r\n          recipientAddress: paymentLink.recipientAddress,\r\n          status: paymentLink.status,\r\n          createdAt: paymentLink.createdAt.toISOString(),\r\n          description: paymentLink.description,\r\n          maxUses: paymentLink.maxUses,\r\n          expiresAt: paymentLink.expiresAt?.toISOString(),\r\n        },\r\n      },\r\n    };\r\n\r\n    return this.send(payload);\r\n  }\r\n\r\n  /**\r\n   * Send subscription event\r\n   */\r\n  async sendSubscriptionEvent(\r\n    event: WebhookEvent,\r\n    subscription: Subscription,\r\n    paymentLink: PaymentLink\r\n  ): Promise<WebhookResult | null> {\r\n    if (!this.isEventEnabled(event)) {\r\n      return null;\r\n    }\r\n\r\n    const payload: WebhookPayload = {\r\n      event,\r\n      timestamp: new Date().toISOString(),\r\n      eventId: this.generateEventId(),\r\n      data: {\r\n        type: 'subscription',\r\n        subscription: {\r\n          id: subscription.id,\r\n          paymentLinkId: subscription.paymentLinkId,\r\n          subscriberAddress: subscription.subscriberAddress,\r\n          status: subscription.status,\r\n          currentPeriodStart: subscription.currentPeriodStart.toISOString(),\r\n          currentPeriodEnd: subscription.currentPeriodEnd.toISOString(),\r\n          nextPaymentDue: subscription.nextPaymentDue.toISOString(),\r\n          cycleCount: subscription.cycleCount,\r\n          createdAt: subscription.createdAt.toISOString(),\r\n          cancelledAt: subscription.cancelledAt?.toISOString(),\r\n          pausedAt: subscription.pausedAt?.toISOString(),\r\n          trialEndsAt: subscription.trialEndsAt?.toISOString(),\r\n        },\r\n        paymentLink: {\r\n          id: paymentLink.id,\r\n          targetUrl: paymentLink.targetUrl,\r\n          price: paymentLink.price,\r\n          recipientAddress: paymentLink.recipientAddress,\r\n          subscription: paymentLink.subscription ? {\r\n            interval: paymentLink.subscription.interval,\r\n            intervalCount: paymentLink.subscription.intervalCount,\r\n          } : undefined,\r\n        },\r\n      },\r\n    };\r\n\r\n    return this.send(payload);\r\n  }\r\n\r\n  /**\r\n   * Queue event for async delivery\r\n   */\r\n  queueEvent(payload: WebhookPayload): void {\r\n    this.queue.push({ payload, attempt: 0 });\r\n    this.processQueue();\r\n  }\r\n\r\n  /**\r\n   * Send webhook with retries\r\n   */\r\n  async send(payload: WebhookPayload): Promise<WebhookResult> {\r\n    const startTime = Date.now();\r\n    let lastError: string | undefined;\r\n    let lastStatusCode: number | undefined;\r\n\r\n    for (let attempt = 1; attempt <= this.config.retries; attempt++) {\r\n      try {\r\n        const result = await this.deliver(payload);\r\n        \r\n        if (result.success) {\r\n          return {\r\n            success: true,\r\n            statusCode: result.statusCode,\r\n            attempts: attempt,\r\n            duration: Date.now() - startTime,\r\n          };\r\n        }\r\n\r\n        lastStatusCode = result.statusCode;\r\n        lastError = result.error;\r\n\r\n        // Don't retry on 4xx errors (client errors)\r\n        if (result.statusCode && result.statusCode >= 400 && result.statusCode < 500) {\r\n          break;\r\n        }\r\n\r\n        // Wait before retry (exponential backoff)\r\n        if (attempt < this.config.retries) {\r\n          await this.delay(Math.pow(2, attempt) * 1000);\r\n        }\r\n      } catch (error) {\r\n        lastError = (error as Error).message;\r\n        \r\n        if (attempt < this.config.retries) {\r\n          await this.delay(Math.pow(2, attempt) * 1000);\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      success: false,\r\n      statusCode: lastStatusCode,\r\n      error: lastError,\r\n      attempts: this.config.retries,\r\n      duration: Date.now() - startTime,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Deliver webhook\r\n   */\r\n  private async deliver(\r\n    payload: WebhookPayload\r\n  ): Promise<{ success: boolean; statusCode?: number; error?: string }> {\r\n    const controller = new AbortController();\r\n    const timeout = setTimeout(() => controller.abort(), this.config.timeout);\r\n\r\n    try {\r\n      const body = JSON.stringify(payload);\r\n      const headers: Record<string, string> = {\r\n        'Content-Type': 'application/json',\r\n        'User-Agent': 'PayPortal-Webhook/1.0.0',\r\n        'X-PayPortal-Event': payload.event,\r\n        'X-PayPortal-Event-Id': payload.eventId,\r\n        'X-PayPortal-Timestamp': payload.timestamp,\r\n        ...this.config.headers,\r\n      };\r\n\r\n      // Add HMAC signature if secret is configured\r\n      if (this.config.secret) {\r\n        headers['X-PayPortal-Signature'] = this.sign(body);\r\n      }\r\n\r\n      const response = await fetch(this.config.url, {\r\n        method: 'POST',\r\n        headers,\r\n        body,\r\n        signal: controller.signal,\r\n      });\r\n\r\n      if (response.ok) {\r\n        return { success: true, statusCode: response.status };\r\n      }\r\n\r\n      return {\r\n        success: false,\r\n        statusCode: response.status,\r\n        error: `HTTP ${response.status}: ${response.statusText}`,\r\n      };\r\n    } catch (error) {\r\n      if ((error as Error).name === 'AbortError') {\r\n        return { success: false, error: 'Request timeout' };\r\n      }\r\n      return { success: false, error: (error as Error).message };\r\n    } finally {\r\n      clearTimeout(timeout);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sign payload with HMAC-SHA256\r\n   */\r\n  private sign(body: string): string {\r\n    if (!this.config.secret) return '';\r\n    return createHmac('sha256', this.config.secret).update(body).digest('hex');\r\n  }\r\n\r\n  /**\r\n   * Generate unique event ID\r\n   */\r\n  private generateEventId(): string {\r\n    const timestamp = Date.now().toString(36);\r\n    const random = Math.random().toString(36).substring(2, 10);\r\n    return `evt_${timestamp}_${random}`;\r\n  }\r\n\r\n  /**\r\n   * Process queued events\r\n   */\r\n  private async processQueue(): Promise<void> {\r\n    if (this.processing) return;\r\n    this.processing = true;\r\n\r\n    while (this.queue.length > 0) {\r\n      const item = this.queue.shift();\r\n      if (!item) continue;\r\n\r\n      const result = await this.send(item.payload);\r\n      \r\n      if (!result.success) {\r\n        console.error(\r\n          `Webhook delivery failed for ${item.payload.event}:`,\r\n          result.error\r\n        );\r\n      }\r\n    }\r\n\r\n    this.processing = false;\r\n  }\r\n\r\n  /**\r\n   * Delay helper\r\n   */\r\n  private delay(ms: number): Promise<void> {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n  }\r\n}\r\n\r\n/**\r\n * Verify webhook signature\r\n * Use this in your webhook handler to verify authenticity\r\n */\r\nexport function verifyWebhookSignature(\r\n  body: string,\r\n  signature: string,\r\n  secret: string\r\n): boolean {\r\n  const expected = createHmac('sha256', secret).update(body).digest('hex');\r\n  \r\n  // Constant-time comparison to prevent timing attacks\r\n  if (signature.length !== expected.length) return false;\r\n  \r\n  let result = 0;\r\n  for (let i = 0; i < signature.length; i++) {\r\n    result |= signature.charCodeAt(i) ^ expected.charCodeAt(i);\r\n  }\r\n  \r\n  return result === 0;\r\n}\r\n\r\n/**\r\n * Create a webhook manager\r\n */\r\nexport function createWebhookManager(config: WebhookConfig): WebhookManager {\r\n  return new WebhookManager(config);\r\n}\r\n","/**\r\n * QR Code Generator\r\n * Generates QR codes for payment links with wallet deep links\r\n */\r\n\r\n// QR Code matrix generation using Reed-Solomon error correction\r\n// This is a pure TypeScript implementation without external dependencies\r\n\r\nconst EC_LEVEL = 1; // M = ~15% error correction\r\nconst MODE_BYTE = 4; // Byte mode indicator\r\n\r\n/**\r\n * QR Code options\r\n */\r\nexport interface QRCodeOptions {\r\n  /** Size in pixels (default: 256) */\r\n  size?: number;\r\n  /** Margin in modules (default: 4) */\r\n  margin?: number;\r\n  /** Dark color (default: #000000) */\r\n  darkColor?: string;\r\n  /** Light color (default: #ffffff) */\r\n  lightColor?: string;\r\n  /** Output format */\r\n  format?: 'svg' | 'png-base64';\r\n}\r\n\r\n/**\r\n * Payment QR data\r\n */\r\nexport interface PaymentQRData {\r\n  /** Chain ID */\r\n  chainId: number;\r\n  /** Recipient address */\r\n  recipient: string;\r\n  /** Amount to pay */\r\n  amount: string;\r\n  /** Token symbol */\r\n  tokenSymbol: string;\r\n  /** Payment link ID */\r\n  paymentLinkId: string;\r\n  /** Callback URL for confirmation */\r\n  confirmUrl: string;\r\n}\r\n\r\n/**\r\n * Generate a payment URI for wallets\r\n */\r\nexport function generatePaymentURI(data: PaymentQRData): string {\r\n  const { chainId, recipient, amount, tokenSymbol } = data;\r\n\r\n  // Solana (chainId 101 = mainnet, 102 = devnet, 103 = testnet)\r\n  if (chainId >= 101 && chainId <= 103) {\r\n    // Solana Pay URI format\r\n    // solana:<recipient>?amount=<amount>&label=<label>&message=<message>\r\n    const params = new URLSearchParams({\r\n      amount: amount,\r\n      label: 'Pay Portal Payment',\r\n      message: `Payment for ${data.paymentLinkId}`,\r\n    });\r\n    return `solana:${recipient}?${params.toString()}`;\r\n  }\r\n\r\n  // EVM chains - use EIP-681 format\r\n  // ethereum:<address>@<chainId>/transfer?value=<value>\r\n  const weiAmount = parseFloat(amount) * 1e18;\r\n  \r\n  // Determine scheme based on chain\r\n  let scheme = 'ethereum';\r\n  if (chainId === 137 || chainId === 80001) {\r\n    scheme = 'polygon';\r\n  } else if (chainId === 56 || chainId === 97) {\r\n    scheme = 'bnb';\r\n  } else if (chainId === 42161 || chainId === 421613) {\r\n    scheme = 'arbitrum';\r\n  }\r\n\r\n  return `${scheme}:${recipient}@${chainId}?value=${weiAmount.toFixed(0)}`;\r\n}\r\n\r\n/**\r\n * Generate QR code as SVG\r\n */\r\nexport function generateQRCodeSVG(data: string, options: QRCodeOptions = {}): string {\r\n  const {\r\n    size = 256,\r\n    margin = 4,\r\n    darkColor = '#000000',\r\n    lightColor = '#ffffff',\r\n  } = options;\r\n\r\n  const matrix = generateQRMatrix(data);\r\n  const moduleCount = matrix.length;\r\n  const moduleSize = size / (moduleCount + margin * 2);\r\n\r\n  let svg = `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 ${size} ${size}\" width=\"${size}\" height=\"${size}\">`;\r\n  svg += `<rect width=\"${size}\" height=\"${size}\" fill=\"${lightColor}\"/>`;\r\n\r\n  for (let row = 0; row < moduleCount; row++) {\r\n    for (let col = 0; col < moduleCount; col++) {\r\n      if (matrix[row][col]) {\r\n        const x = (col + margin) * moduleSize;\r\n        const y = (row + margin) * moduleSize;\r\n        svg += `<rect x=\"${x}\" y=\"${y}\" width=\"${moduleSize}\" height=\"${moduleSize}\" fill=\"${darkColor}\"/>`;\r\n      }\r\n    }\r\n  }\r\n\r\n  svg += '</svg>';\r\n  return svg;\r\n}\r\n\r\n/**\r\n * Generate QR code as data URL (base64 PNG simulation via SVG)\r\n */\r\nexport function generateQRCodeDataURL(data: string, options: QRCodeOptions = {}): string {\r\n  const svg = generateQRCodeSVG(data, options);\r\n  const base64 = Buffer.from(svg).toString('base64');\r\n  return `data:image/svg+xml;base64,${base64}`;\r\n}\r\n\r\n/**\r\n * Generate complete payment QR code\r\n */\r\nexport function generatePaymentQR(\r\n  data: PaymentQRData,\r\n  options: QRCodeOptions = {}\r\n): { uri: string; svg: string; dataUrl: string } {\r\n  const uri = generatePaymentURI(data);\r\n  const svg = generateQRCodeSVG(uri, options);\r\n  const dataUrl = generateQRCodeDataURL(uri, options);\r\n\r\n  return { uri, svg, dataUrl };\r\n}\r\n\r\n// ============================================\r\n// QR Matrix Generation (Simplified Version 2)\r\n// ============================================\r\n\r\nfunction generateQRMatrix(data: string): boolean[][] {\r\n  const bytes = Buffer.from(data, 'utf8');\r\n  const version = getMinVersion(bytes.length);\r\n  const size = version * 4 + 17;\r\n\r\n  // Initialize matrix\r\n  const matrix: boolean[][] = Array(size)\r\n    .fill(null)\r\n    .map(() => Array(size).fill(false));\r\n\r\n  const reserved: boolean[][] = Array(size)\r\n    .fill(null)\r\n    .map(() => Array(size).fill(false));\r\n\r\n  // Add finder patterns\r\n  addFinderPattern(matrix, reserved, 0, 0);\r\n  addFinderPattern(matrix, reserved, size - 7, 0);\r\n  addFinderPattern(matrix, reserved, 0, size - 7);\r\n\r\n  // Add timing patterns\r\n  addTimingPatterns(matrix, reserved, size);\r\n\r\n  // Add alignment patterns (for version 2+)\r\n  if (version >= 2) {\r\n    addAlignmentPatterns(matrix, reserved, version, size);\r\n  }\r\n\r\n  // Reserve format info areas\r\n  reserveFormatAreas(reserved, size);\r\n\r\n  // Encode data\r\n  const encoded = encodeData(bytes, version);\r\n\r\n  // Place data in matrix\r\n  placeData(matrix, reserved, encoded, size);\r\n\r\n  // Apply mask (using mask 0 for simplicity)\r\n  applyMask(matrix, reserved, size, 0);\r\n\r\n  // Add format info\r\n  addFormatInfo(matrix, size, 0);\r\n\r\n  return matrix;\r\n}\r\n\r\nfunction getMinVersion(dataLength: number): number {\r\n  // Simplified version selection for byte mode with M error correction\r\n  const capacities = [0, 14, 26, 42, 62, 84, 106, 122, 152, 180, 213];\r\n  for (let v = 1; v <= 10; v++) {\r\n    if (dataLength <= capacities[v]) return v;\r\n  }\r\n  return 10; // Max version we support\r\n}\r\n\r\nfunction addFinderPattern(\r\n  matrix: boolean[][],\r\n  reserved: boolean[][],\r\n  row: number,\r\n  col: number\r\n): void {\r\n  for (let r = -1; r <= 7; r++) {\r\n    for (let c = -1; c <= 7; c++) {\r\n      const rr = row + r;\r\n      const cc = col + c;\r\n      if (rr < 0 || cc < 0 || rr >= matrix.length || cc >= matrix.length) continue;\r\n\r\n      reserved[rr][cc] = true;\r\n\r\n      if (r === -1 || r === 7 || c === -1 || c === 7) {\r\n        matrix[rr][cc] = false;\r\n      } else if (r === 0 || r === 6 || c === 0 || c === 6) {\r\n        matrix[rr][cc] = true;\r\n      } else if (r >= 2 && r <= 4 && c >= 2 && c <= 4) {\r\n        matrix[rr][cc] = true;\r\n      } else {\r\n        matrix[rr][cc] = false;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction addTimingPatterns(matrix: boolean[][], reserved: boolean[][], size: number): void {\r\n  for (let i = 8; i < size - 8; i++) {\r\n    const bit = i % 2 === 0;\r\n    matrix[6][i] = bit;\r\n    matrix[i][6] = bit;\r\n    reserved[6][i] = true;\r\n    reserved[i][6] = true;\r\n  }\r\n}\r\n\r\nfunction addAlignmentPatterns(\r\n  matrix: boolean[][],\r\n  reserved: boolean[][],\r\n  version: number,\r\n  size: number\r\n): void {\r\n  const positions = getAlignmentPositions(version);\r\n\r\n  for (const row of positions) {\r\n    for (const col of positions) {\r\n      // Skip if overlapping with finder patterns\r\n      if (\r\n        (row < 9 && col < 9) ||\r\n        (row < 9 && col > size - 10) ||\r\n        (row > size - 10 && col < 9)\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      for (let r = -2; r <= 2; r++) {\r\n        for (let c = -2; c <= 2; c++) {\r\n          const rr = row + r;\r\n          const cc = col + c;\r\n          reserved[rr][cc] = true;\r\n\r\n          if (r === -2 || r === 2 || c === -2 || c === 2) {\r\n            matrix[rr][cc] = true;\r\n          } else if (r === 0 && c === 0) {\r\n            matrix[rr][cc] = true;\r\n          } else {\r\n            matrix[rr][cc] = false;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction getAlignmentPositions(version: number): number[] {\r\n  if (version === 1) return [];\r\n  const positions = [6];\r\n  const step = Math.floor((version * 4 + 10) / (Math.floor(version / 7) + 1));\r\n  let pos = version * 4 + 10;\r\n  while (pos > 6 + step) {\r\n    positions.unshift(pos);\r\n    pos -= step;\r\n  }\r\n  positions.unshift(6);\r\n  return [...new Set(positions)].sort((a, b) => a - b);\r\n}\r\n\r\nfunction reserveFormatAreas(reserved: boolean[][], size: number): void {\r\n  // Around top-left finder\r\n  for (let i = 0; i < 9; i++) {\r\n    reserved[8][i] = true;\r\n    reserved[i][8] = true;\r\n  }\r\n  // Around top-right finder\r\n  for (let i = 0; i < 8; i++) {\r\n    reserved[8][size - 1 - i] = true;\r\n  }\r\n  // Around bottom-left finder\r\n  for (let i = 0; i < 8; i++) {\r\n    reserved[size - 1 - i][8] = true;\r\n  }\r\n  // Dark module\r\n  reserved[size - 8][8] = true;\r\n}\r\n\r\nfunction encodeData(data: Buffer, version: number): boolean[] {\r\n  const bits: boolean[] = [];\r\n\r\n  // Mode indicator (byte mode = 0100)\r\n  pushBits(bits, MODE_BYTE, 4);\r\n\r\n  // Character count (8 bits for version 1-9, 16 for 10+)\r\n  const countBits = version < 10 ? 8 : 16;\r\n  pushBits(bits, data.length, countBits);\r\n\r\n  // Data\r\n  for (const byte of data) {\r\n    pushBits(bits, byte, 8);\r\n  }\r\n\r\n  // Terminator\r\n  const capacity = getDataCapacity(version);\r\n  const remaining = capacity - bits.length;\r\n  if (remaining > 0) {\r\n    pushBits(bits, 0, Math.min(4, remaining));\r\n  }\r\n\r\n  // Pad to byte boundary\r\n  while (bits.length % 8 !== 0) {\r\n    bits.push(false);\r\n  }\r\n\r\n  // Pad codewords\r\n  const padBytes = [0xec, 0x11];\r\n  let padIndex = 0;\r\n  while (bits.length < capacity) {\r\n    pushBits(bits, padBytes[padIndex % 2], 8);\r\n    padIndex++;\r\n  }\r\n\r\n  // Add error correction\r\n  return addErrorCorrection(bits, version);\r\n}\r\n\r\nfunction getDataCapacity(version: number): number {\r\n  // Data capacity in bits for M error correction level\r\n  const capacities = [0, 128, 224, 352, 512, 688, 864, 992, 1232, 1456, 1728];\r\n  return capacities[version] || 1728;\r\n}\r\n\r\nfunction pushBits(arr: boolean[], value: number, count: number): void {\r\n  for (let i = count - 1; i >= 0; i--) {\r\n    arr.push(((value >> i) & 1) === 1);\r\n  }\r\n}\r\n\r\nfunction addErrorCorrection(data: boolean[], version: number): boolean[] {\r\n  // Simplified: For versions 1-10 with M level, add basic EC\r\n  // In production, use proper Reed-Solomon encoding\r\n\r\n  const dataBytes: number[] = [];\r\n  for (let i = 0; i < data.length; i += 8) {\r\n    let byte = 0;\r\n    for (let j = 0; j < 8 && i + j < data.length; j++) {\r\n      if (data[i + j]) byte |= 1 << (7 - j);\r\n    }\r\n    dataBytes.push(byte);\r\n  }\r\n\r\n  // Generate EC codewords (simplified polynomial division)\r\n  const ecCount = getECCount(version);\r\n  const ecBytes = generateECBytes(dataBytes, ecCount);\r\n\r\n  // Combine data and EC\r\n  const result: boolean[] = [...data];\r\n  for (const byte of ecBytes) {\r\n    pushBits(result, byte, 8);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction getECCount(version: number): number {\r\n  // EC codewords for M level\r\n  const counts = [0, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26];\r\n  return counts[version] || 26;\r\n}\r\n\r\nfunction generateECBytes(data: number[], ecCount: number): number[] {\r\n  // Simplified Reed-Solomon using GF(256)\r\n  const gfExp = new Uint8Array(512);\r\n  const gfLog = new Uint8Array(256);\r\n\r\n  // Generate GF tables\r\n  let x = 1;\r\n  for (let i = 0; i < 255; i++) {\r\n    gfExp[i] = x;\r\n    gfLog[x] = i;\r\n    x <<= 1;\r\n    if (x & 0x100) x ^= 0x11d;\r\n  }\r\n  for (let i = 255; i < 512; i++) {\r\n    gfExp[i] = gfExp[i - 255];\r\n  }\r\n\r\n  // Generate generator polynomial\r\n  const gen: number[] = [1];\r\n  for (let i = 0; i < ecCount; i++) {\r\n    const newGen: number[] = new Array(gen.length + 1).fill(0);\r\n    for (let j = 0; j < gen.length; j++) {\r\n      newGen[j] ^= gen[j];\r\n      newGen[j + 1] ^= gfExp[(gfLog[gen[j]] + i) % 255];\r\n    }\r\n    gen.length = 0;\r\n    gen.push(...newGen);\r\n  }\r\n\r\n  // Perform polynomial division\r\n  const msg = [...data, ...new Array(ecCount).fill(0)];\r\n  for (let i = 0; i < data.length; i++) {\r\n    const coef = msg[i];\r\n    if (coef !== 0) {\r\n      for (let j = 1; j < gen.length; j++) {\r\n        if (gen[j] !== 0) {\r\n          msg[i + j] ^= gfExp[(gfLog[gen[j]] + gfLog[coef]) % 255];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return msg.slice(data.length);\r\n}\r\n\r\nfunction placeData(\r\n  matrix: boolean[][],\r\n  reserved: boolean[][],\r\n  data: boolean[],\r\n  size: number\r\n): void {\r\n  let dataIndex = 0;\r\n  let upward = true;\r\n\r\n  for (let col = size - 1; col > 0; col -= 2) {\r\n    if (col === 6) col = 5; // Skip timing pattern column\r\n\r\n    for (let i = 0; i < size; i++) {\r\n      const row = upward ? size - 1 - i : i;\r\n\r\n      for (const c of [col, col - 1]) {\r\n        if (!reserved[row][c] && dataIndex < data.length) {\r\n          matrix[row][c] = data[dataIndex++];\r\n        }\r\n      }\r\n    }\r\n\r\n    upward = !upward;\r\n  }\r\n}\r\n\r\nfunction applyMask(\r\n  matrix: boolean[][],\r\n  reserved: boolean[][],\r\n  size: number,\r\n  mask: number\r\n): void {\r\n  for (let row = 0; row < size; row++) {\r\n    for (let col = 0; col < size; col++) {\r\n      if (!reserved[row][col] && shouldMask(row, col, mask)) {\r\n        matrix[row][col] = !matrix[row][col];\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction shouldMask(row: number, col: number, mask: number): boolean {\r\n  switch (mask) {\r\n    case 0:\r\n      return (row + col) % 2 === 0;\r\n    case 1:\r\n      return row % 2 === 0;\r\n    case 2:\r\n      return col % 3 === 0;\r\n    case 3:\r\n      return (row + col) % 3 === 0;\r\n    case 4:\r\n      return (Math.floor(row / 2) + Math.floor(col / 3)) % 2 === 0;\r\n    case 5:\r\n      return ((row * col) % 2) + ((row * col) % 3) === 0;\r\n    case 6:\r\n      return (((row * col) % 2) + ((row * col) % 3)) % 2 === 0;\r\n    case 7:\r\n      return (((row + col) % 2) + ((row * col) % 3)) % 2 === 0;\r\n    default:\r\n      return false;\r\n  }\r\n}\r\n\r\nfunction addFormatInfo(matrix: boolean[][], size: number, mask: number): void {\r\n  // Format info for EC level M (01) and mask\r\n  const formatBits = getFormatBits(EC_LEVEL, mask);\r\n\r\n  // Place format info\r\n  for (let i = 0; i < 15; i++) {\r\n    const bit = formatBits[i];\r\n\r\n    // Around top-left\r\n    if (i < 6) {\r\n      matrix[i][8] = bit;\r\n    } else if (i < 8) {\r\n      matrix[i + 1][8] = bit;\r\n    } else {\r\n      matrix[8][14 - i] = bit;\r\n    }\r\n\r\n    // Around top-right and bottom-left\r\n    if (i < 8) {\r\n      matrix[8][size - 1 - i] = bit;\r\n    } else {\r\n      matrix[size - 15 + i][8] = bit;\r\n    }\r\n  }\r\n\r\n  // Dark module\r\n  matrix[size - 8][8] = true;\r\n}\r\n\r\nfunction getFormatBits(ecLevel: number, mask: number): boolean[] {\r\n  // Pre-computed format strings for M level (01) and masks 0-7\r\n  const formats: { [key: string]: string } = {\r\n    '1-0': '101010000010010',\r\n    '1-1': '101000100100101',\r\n    '1-2': '101111001111100',\r\n    '1-3': '101101101001011',\r\n    '1-4': '100010111111001',\r\n    '1-5': '100000011001110',\r\n    '1-6': '100111110010111',\r\n    '1-7': '100101010100000',\r\n  };\r\n\r\n  const key = `${ecLevel}-${mask}`;\r\n  const format = formats[key] || formats['1-0'];\r\n\r\n  return format.split('').map(c => c === '1');\r\n}\r\n","import type { \r\n  PaymentLink, \r\n  Protocol402Response, \r\n  Protocol403Response,\r\n  ReasonCode,\r\n} from './types.js';\r\nimport { REASON_MESSAGES } from './utils.js';\r\nimport { generateNonce, createSignature } from './utils.js';\r\n\r\nexport interface Protocol402Options {\r\n  basePath: string;\r\n  timeoutSeconds: number;\r\n  signatureSecret?: string;\r\n  /** Base URL for callbacks (e.g., https://sn1ffprotocol.com) */\r\n  baseUrl?: string;\r\n}\r\n\r\n/**\r\n * Build a 402 Payment Required response body\r\n */\r\nexport function build402Response(\r\n  paymentLink: PaymentLink,\r\n  options: Protocol402Options\r\n): Protocol402Response {\r\n  const nonce = generateNonce();\r\n  const baseUrl = options.baseUrl || '';\r\n  \r\n  const response: Protocol402Response = {\r\n    protocol: '402-payportal-v1',\r\n    paymentLinkId: paymentLink.id,\r\n    resource: {\r\n      description: paymentLink.description,\r\n      preview: null,\r\n    },\r\n    payment: {\r\n      chainId: paymentLink.price.chainId,\r\n      tokenSymbol: paymentLink.price.tokenSymbol,\r\n      amount: paymentLink.price.amount,\r\n      recipient: paymentLink.recipientAddress,\r\n      timeoutSeconds: options.timeoutSeconds,\r\n    },\r\n    callbacks: {\r\n      status: `${baseUrl}${options.basePath}/${paymentLink.id}/status`,\r\n      confirm: `${baseUrl}${options.basePath}/${paymentLink.id}/confirm`,\r\n    },\r\n    nonce,\r\n  };\r\n\r\n  // Add signature if secret is provided\r\n  if (options.signatureSecret) {\r\n    const dataToSign = JSON.stringify({\r\n      paymentLinkId: response.paymentLinkId,\r\n      payment: response.payment,\r\n      nonce: response.nonce,\r\n    });\r\n    response.signature = createSignature(dataToSign, options.signatureSecret);\r\n  }\r\n\r\n  return response;\r\n}\r\n\r\nexport interface Protocol403Options {\r\n  paymentLinkId?: string;\r\n  details?: Record<string, unknown>;\r\n}\r\n\r\n/**\r\n * Build a 403 Forbidden response body\r\n */\r\nexport function build403Response(\r\n  reasonCode: ReasonCode,\r\n  options: Protocol403Options = {}\r\n): Protocol403Response {\r\n  return {\r\n    protocol: '403-payportal-v1',\r\n    paymentLinkId: options.paymentLinkId,\r\n    reasonCode,\r\n    reasonMessage: REASON_MESSAGES[reasonCode],\r\n    details: options.details,\r\n  };\r\n}\r\n\r\n/**\r\n * HTTP headers for 402 response\r\n */\r\nexport const HEADERS_402 = {\r\n  'Content-Type': 'application/json; charset=utf-8',\r\n  'X-PayPortal-Protocol': '402-v1',\r\n} as const;\r\n\r\n/**\r\n * HTTP headers for 403 response\r\n */\r\nexport const HEADERS_403 = {\r\n  'Content-Type': 'application/json; charset=utf-8',\r\n  'X-PayPortal-Protocol': '403-v1',\r\n} as const;\r\n","import type {\r\n  Subscription,\r\n  SubscriptionConfig,\r\n  SubscriptionInterval,\r\n  SubscriptionStatus,\r\n  PaymentLink,\r\n  Payment,\r\n  Storage,\r\n  CreateSubscriptionInput,\r\n} from './types.js';\r\nimport { generateId, generateUUID } from './utils.js';\r\n\r\n/**\r\n * Calculate next billing date based on interval\r\n */\r\nexport function calculateNextBillingDate(\r\n  fromDate: Date,\r\n  interval: SubscriptionInterval,\r\n  intervalCount: number = 1\r\n): Date {\r\n  const date = new Date(fromDate);\r\n\r\n  switch (interval) {\r\n    case 'daily':\r\n      date.setDate(date.getDate() + intervalCount);\r\n      break;\r\n    case 'weekly':\r\n      date.setDate(date.getDate() + (7 * intervalCount));\r\n      break;\r\n    case 'monthly':\r\n      date.setMonth(date.getMonth() + intervalCount);\r\n      break;\r\n    case 'yearly':\r\n      date.setFullYear(date.getFullYear() + intervalCount);\r\n      break;\r\n  }\r\n\r\n  return date;\r\n}\r\n\r\n/**\r\n * Check if subscription is within grace period\r\n */\r\nexport function isWithinGracePeriod(\r\n  nextPaymentDue: Date,\r\n  gracePeriodHours: number = 24\r\n): boolean {\r\n  const now = new Date();\r\n  const graceEnd = new Date(nextPaymentDue);\r\n  graceEnd.setHours(graceEnd.getHours() + gracePeriodHours);\r\n  return now <= graceEnd;\r\n}\r\n\r\n/**\r\n * Check if subscription payment is due\r\n */\r\nexport function isPaymentDue(subscription: Subscription): boolean {\r\n  const now = new Date();\r\n  return now >= subscription.nextPaymentDue;\r\n}\r\n\r\n/**\r\n * Check if subscription is in trial period\r\n */\r\nexport function isInTrialPeriod(subscription: Subscription): boolean {\r\n  if (!subscription.trialEndsAt) return false;\r\n  return new Date() < subscription.trialEndsAt;\r\n}\r\n\r\n/**\r\n * Get interval display name\r\n */\r\nexport function getIntervalDisplayName(\r\n  interval: SubscriptionInterval,\r\n  count: number = 1\r\n): string {\r\n  const labels: Record<SubscriptionInterval, [string, string]> = {\r\n    daily: ['day', 'days'],\r\n    weekly: ['week', 'weeks'],\r\n    monthly: ['month', 'months'],\r\n    yearly: ['year', 'years'],\r\n  };\r\n\r\n  const [singular, plural] = labels[interval];\r\n  if (count === 1) return singular;\r\n  return `${count} ${plural}`;\r\n}\r\n\r\n/**\r\n * Subscription Manager\r\n * Handles subscription lifecycle and billing\r\n */\r\nexport class SubscriptionManager {\r\n  private storage: Storage;\r\n  private checkInterval: NodeJS.Timeout | null = null;\r\n\r\n  constructor(storage: Storage) {\r\n    this.storage = storage;\r\n  }\r\n\r\n  /**\r\n   * Create a new subscription\r\n   */\r\n  async createSubscription(\r\n    paymentLink: PaymentLink,\r\n    input: CreateSubscriptionInput\r\n  ): Promise<Subscription> {\r\n    if (!paymentLink.subscription) {\r\n      throw new Error('PaymentLink is not configured for subscriptions');\r\n    }\r\n\r\n    const config = paymentLink.subscription;\r\n    const now = new Date();\r\n\r\n    // Check for existing subscription\r\n    const existing = await this.storage.getSubscriptionByAddress(\r\n      paymentLink.id,\r\n      input.subscriberAddress\r\n    );\r\n\r\n    if (existing && existing.status === 'active') {\r\n      throw new Error('Active subscription already exists for this address');\r\n    }\r\n\r\n    // Calculate dates\r\n    const trialEndsAt = config.trialDays\r\n      ? new Date(now.getTime() + config.trialDays * 24 * 60 * 60 * 1000)\r\n      : undefined;\r\n\r\n    const periodStart = trialEndsAt ?? now;\r\n    const periodEnd = calculateNextBillingDate(\r\n      periodStart,\r\n      config.interval,\r\n      config.intervalCount\r\n    );\r\n\r\n    const subscription: Subscription = {\r\n      id: generateId(12),\r\n      paymentLinkId: paymentLink.id,\r\n      subscriberAddress: input.subscriberAddress,\r\n      status: 'active',\r\n      currentPeriodStart: periodStart,\r\n      currentPeriodEnd: periodEnd,\r\n      nextPaymentDue: trialEndsAt ?? now,\r\n      cycleCount: 0,\r\n      createdAt: now,\r\n      updatedAt: now,\r\n      trialEndsAt,\r\n      metadata: input.metadata,\r\n    };\r\n\r\n    await this.storage.saveSubscription(subscription);\r\n    return subscription;\r\n  }\r\n\r\n  /**\r\n   * Process payment for subscription\r\n   */\r\n  async processPayment(\r\n    subscription: Subscription,\r\n    payment: Payment,\r\n    paymentLink: PaymentLink\r\n  ): Promise<Subscription> {\r\n    if (!paymentLink.subscription) {\r\n      throw new Error('PaymentLink is not configured for subscriptions');\r\n    }\r\n\r\n    const config = paymentLink.subscription;\r\n    const now = new Date();\r\n\r\n    // Calculate new period\r\n    const newPeriodStart = subscription.currentPeriodEnd;\r\n    const newPeriodEnd = calculateNextBillingDate(\r\n      newPeriodStart,\r\n      config.interval,\r\n      config.intervalCount\r\n    );\r\n\r\n    // Update subscription\r\n    subscription.currentPeriodStart = newPeriodStart;\r\n    subscription.currentPeriodEnd = newPeriodEnd;\r\n    subscription.nextPaymentDue = newPeriodEnd;\r\n    subscription.cycleCount += 1;\r\n    subscription.lastPaymentId = payment.id;\r\n    subscription.status = 'active';\r\n    subscription.updatedAt = now;\r\n\r\n    // Check max cycles\r\n    if (config.maxCycles && subscription.cycleCount >= config.maxCycles) {\r\n      subscription.status = 'expired';\r\n    }\r\n\r\n    await this.storage.updateSubscription(subscription);\r\n    return subscription;\r\n  }\r\n\r\n  /**\r\n   * Cancel subscription\r\n   */\r\n  async cancelSubscription(\r\n    subscriptionId: string,\r\n    immediate: boolean = false\r\n  ): Promise<Subscription> {\r\n    const subscription = await this.storage.getSubscription(subscriptionId);\r\n    if (!subscription) {\r\n      throw new Error('Subscription not found');\r\n    }\r\n\r\n    subscription.status = 'cancelled';\r\n    subscription.cancelledAt = new Date();\r\n    subscription.updatedAt = new Date();\r\n\r\n    await this.storage.updateSubscription(subscription);\r\n    return subscription;\r\n  }\r\n\r\n  /**\r\n   * Pause subscription\r\n   */\r\n  async pauseSubscription(subscriptionId: string): Promise<Subscription> {\r\n    const subscription = await this.storage.getSubscription(subscriptionId);\r\n    if (!subscription) {\r\n      throw new Error('Subscription not found');\r\n    }\r\n\r\n    if (subscription.status !== 'active') {\r\n      throw new Error('Only active subscriptions can be paused');\r\n    }\r\n\r\n    subscription.status = 'paused';\r\n    subscription.pausedAt = new Date();\r\n    subscription.updatedAt = new Date();\r\n\r\n    await this.storage.updateSubscription(subscription);\r\n    return subscription;\r\n  }\r\n\r\n  /**\r\n   * Resume subscription\r\n   */\r\n  async resumeSubscription(subscriptionId: string): Promise<Subscription> {\r\n    const subscription = await this.storage.getSubscription(subscriptionId);\r\n    if (!subscription) {\r\n      throw new Error('Subscription not found');\r\n    }\r\n\r\n    if (subscription.status !== 'paused') {\r\n      throw new Error('Only paused subscriptions can be resumed');\r\n    }\r\n\r\n    subscription.status = 'active';\r\n    subscription.pausedAt = undefined;\r\n    subscription.updatedAt = new Date();\r\n\r\n    await this.storage.updateSubscription(subscription);\r\n    return subscription;\r\n  }\r\n\r\n  /**\r\n   * Check subscription access\r\n   * Returns true if subscription grants access to the resource\r\n   */\r\n  async checkAccess(subscription: Subscription, paymentLink: PaymentLink): Promise<{\r\n    hasAccess: boolean;\r\n    reason?: string;\r\n    requiresPayment?: boolean;\r\n  }> {\r\n    // Check if cancelled\r\n    if (subscription.status === 'cancelled') {\r\n      return {\r\n        hasAccess: false,\r\n        reason: 'Subscription has been cancelled',\r\n      };\r\n    }\r\n\r\n    // Check if expired\r\n    if (subscription.status === 'expired') {\r\n      return {\r\n        hasAccess: false,\r\n        reason: 'Subscription has expired',\r\n      };\r\n    }\r\n\r\n    // Check if paused\r\n    if (subscription.status === 'paused') {\r\n      return {\r\n        hasAccess: false,\r\n        reason: 'Subscription is paused',\r\n      };\r\n    }\r\n\r\n    // Check trial period\r\n    if (isInTrialPeriod(subscription)) {\r\n      return { hasAccess: true };\r\n    }\r\n\r\n    // Check if payment is due\r\n    if (isPaymentDue(subscription)) {\r\n      const gracePeriodHours = paymentLink.subscription?.gracePeriodHours ?? 24;\r\n\r\n      if (isWithinGracePeriod(subscription.nextPaymentDue, gracePeriodHours)) {\r\n        // Still in grace period\r\n        return {\r\n          hasAccess: true,\r\n          requiresPayment: true,\r\n        };\r\n      }\r\n\r\n      // Past grace period\r\n      return {\r\n        hasAccess: false,\r\n        reason: 'Payment is past due',\r\n        requiresPayment: true,\r\n      };\r\n    }\r\n\r\n    return { hasAccess: true };\r\n  }\r\n\r\n  /**\r\n   * Mark subscription as past due\r\n   */\r\n  async markPastDue(subscriptionId: string): Promise<Subscription> {\r\n    const subscription = await this.storage.getSubscription(subscriptionId);\r\n    if (!subscription) {\r\n      throw new Error('Subscription not found');\r\n    }\r\n\r\n    subscription.status = 'past_due';\r\n    subscription.updatedAt = new Date();\r\n\r\n    await this.storage.updateSubscription(subscription);\r\n    return subscription;\r\n  }\r\n\r\n  /**\r\n   * Get subscription by ID\r\n   */\r\n  async getSubscription(id: string): Promise<Subscription | null> {\r\n    return this.storage.getSubscription(id);\r\n  }\r\n\r\n  /**\r\n   * Get subscription by subscriber address\r\n   */\r\n  async getSubscriptionByAddress(\r\n    paymentLinkId: string,\r\n    subscriberAddress: string\r\n  ): Promise<Subscription | null> {\r\n    return this.storage.getSubscriptionByAddress(paymentLinkId, subscriberAddress);\r\n  }\r\n\r\n  /**\r\n   * Get all subscriptions due for payment\r\n   */\r\n  async getDueSubscriptions(): Promise<Subscription[]> {\r\n    return this.storage.getSubscriptionsDue(new Date());\r\n  }\r\n\r\n  /**\r\n   * Start periodic check for due subscriptions\r\n   */\r\n  startPeriodicCheck(\r\n    intervalMs: number = 60000,\r\n    onDue?: (subscription: Subscription) => void\r\n  ): void {\r\n    if (this.checkInterval) {\r\n      clearInterval(this.checkInterval);\r\n    }\r\n\r\n    this.checkInterval = setInterval(async () => {\r\n      try {\r\n        const dueSubscriptions = await this.getDueSubscriptions();\r\n        for (const sub of dueSubscriptions) {\r\n          if (onDue) {\r\n            onDue(sub);\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error('Subscription check error:', error);\r\n      }\r\n    }, intervalMs);\r\n  }\r\n\r\n  /**\r\n   * Stop periodic check\r\n   */\r\n  stopPeriodicCheck(): void {\r\n    if (this.checkInterval) {\r\n      clearInterval(this.checkInterval);\r\n      this.checkInterval = null;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Create subscription manager\r\n */\r\nexport function createSubscriptionManager(storage: Storage): SubscriptionManager {\r\n  return new SubscriptionManager(storage);\r\n}\r\n","import type { Storage, PaymentLink, Payment, Subscription } from '../types.js';\r\n\r\n/**\r\n * In-memory storage implementation for development and testing\r\n */\r\nexport class MemoryStorage implements Storage {\r\n  private paymentLinks: Map<string, PaymentLink> = new Map();\r\n  private payments = new Map<string, Payment>();\r\n  private paymentsByTxHash = new Map<string, Payment>();\r\n  private paymentsByPaymentLinkId = new Map<string, Payment[]>();\r\n  private subscriptions = new Map<string, Subscription>();\r\n  private subscriptionsByAddress = new Map<string, Subscription>();\r\n  private subscriptionsByPaymentLink = new Map<string, Subscription[]>();\r\n\r\n  async getPaymentLink(id: string): Promise<PaymentLink | null> {\r\n    return this.paymentLinks.get(id) ?? null;\r\n  }\r\n\r\n  async savePaymentLink(paymentLink: PaymentLink): Promise<void> {\r\n    this.paymentLinks.set(paymentLink.id, { ...paymentLink });\r\n  }\r\n\r\n  async updatePaymentLink(paymentLink: PaymentLink): Promise<void> {\r\n    if (!this.paymentLinks.has(paymentLink.id)) {\r\n      throw new Error(`Payment link ${paymentLink.id} not found`);\r\n    }\r\n    this.paymentLinks.set(paymentLink.id, { ...paymentLink, updatedAt: new Date() });\r\n  }\r\n\r\n  async deletePaymentLink(id: string): Promise<void> {\r\n    this.paymentLinks.delete(id);\r\n  }\r\n\r\n  async savePayment(payment: Payment): Promise<void> {\r\n    this.payments.set(payment.id, { ...payment });\r\n    this.paymentsByTxHash.set(payment.txHash, payment);\r\n    \r\n    const existing = this.paymentsByPaymentLinkId.get(payment.paymentLinkId) ?? [];\r\n    existing.push(payment);\r\n    this.paymentsByPaymentLinkId.set(payment.paymentLinkId, existing);\r\n  }\r\n\r\n  async getPaymentByTxHash(txHash: string): Promise<Payment | null> {\r\n    return this.paymentsByTxHash.get(txHash) ?? null;\r\n  }\r\n\r\n  async getConfirmedPayment(paymentLinkId: string): Promise<Payment | null> {\r\n    const payments = this.paymentsByPaymentLinkId.get(paymentLinkId) ?? [];\r\n    return payments.find(p => p.confirmed) ?? null;\r\n  }\r\n\r\n  /**\r\n   * Clear all data (useful for testing)\r\n   */\r\n  clear(): void {\r\n    this.paymentLinks.clear();\r\n    this.payments.clear();\r\n    this.paymentsByTxHash.clear();\r\n    this.paymentsByPaymentLinkId.clear();\r\n    this.subscriptions.clear();\r\n    this.subscriptionsByAddress.clear();\r\n    this.subscriptionsByPaymentLink.clear();\r\n  }\r\n\r\n  /**\r\n   * Get all payment links (useful for debugging)\r\n   */\r\n  async getAllPaymentLinks(): Promise<PaymentLink[]> {\r\n    return Array.from(this.paymentLinks.values());\r\n  }\r\n\r\n  /**\r\n   * Get all payments (useful for debugging)\r\n   */\r\n  async getAllPayments(): Promise<Payment[]> {\r\n    return Array.from(this.payments.values());\r\n  }\r\n\r\n  // Subscription methods\r\n\r\n  async saveSubscription(subscription: Subscription): Promise<void> {\r\n    this.subscriptions.set(subscription.id, { ...subscription });\r\n    \r\n    // Index by address\r\n    const addressKey = `${subscription.paymentLinkId}:${subscription.subscriberAddress}`;\r\n    this.subscriptionsByAddress.set(addressKey, subscription);\r\n    \r\n    // Index by payment link\r\n    const linkSubs = this.subscriptionsByPaymentLink.get(subscription.paymentLinkId) ?? [];\r\n    linkSubs.push(subscription);\r\n    this.subscriptionsByPaymentLink.set(subscription.paymentLinkId, linkSubs);\r\n  }\r\n\r\n  async getSubscription(id: string): Promise<Subscription | null> {\r\n    return this.subscriptions.get(id) ?? null;\r\n  }\r\n\r\n  async updateSubscription(subscription: Subscription): Promise<void> {\r\n    if (!this.subscriptions.has(subscription.id)) {\r\n      throw new Error(`Subscription ${subscription.id} not found`);\r\n    }\r\n    \r\n    const updated = { ...subscription, updatedAt: new Date() };\r\n    this.subscriptions.set(subscription.id, updated);\r\n    \r\n    // Update address index\r\n    const addressKey = `${subscription.paymentLinkId}:${subscription.subscriberAddress}`;\r\n    this.subscriptionsByAddress.set(addressKey, updated);\r\n    \r\n    // Update payment link index\r\n    const linkSubs = this.subscriptionsByPaymentLink.get(subscription.paymentLinkId) ?? [];\r\n    const idx = linkSubs.findIndex(s => s.id === subscription.id);\r\n    if (idx !== -1) {\r\n      linkSubs[idx] = updated;\r\n    }\r\n  }\r\n\r\n  async getSubscriptionByAddress(\r\n    paymentLinkId: string,\r\n    subscriberAddress: string\r\n  ): Promise<Subscription | null> {\r\n    const addressKey = `${paymentLinkId}:${subscriberAddress}`;\r\n    return this.subscriptionsByAddress.get(addressKey) ?? null;\r\n  }\r\n\r\n  async getSubscriptionsByPaymentLink(paymentLinkId: string): Promise<Subscription[]> {\r\n    return this.subscriptionsByPaymentLink.get(paymentLinkId) ?? [];\r\n  }\r\n\r\n  async getSubscriptionsDue(beforeDate: Date): Promise<Subscription[]> {\r\n    const result: Subscription[] = [];\r\n    for (const sub of this.subscriptions.values()) {\r\n      if (\r\n        sub.status === 'active' &&\r\n        sub.nextPaymentDue <= beforeDate\r\n      ) {\r\n        result.push(sub);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  async getAllSubscriptions(): Promise<Subscription[]> {\r\n    return Array.from(this.subscriptions.values());\r\n  }\r\n}\r\n\r\n/**\r\n * Create a new in-memory storage instance\r\n */\r\nexport function createMemoryStorage(): MemoryStorage {\r\n  return new MemoryStorage();\r\n}\r\n","import type { PaymentProvider, PaymentStatusResult } from '../types.js';\r\nimport { compareAmounts } from '../utils.js';\r\n\r\nexport interface MockPaymentConfig {\r\n  /** Default status to return */\r\n  defaultStatus?: 'confirmed' | 'pending' | 'failed';\r\n  /** Simulate network delay in ms */\r\n  simulateDelay?: number;\r\n  /** Simulate underpaid by this percentage (0-100) */\r\n  underpaidPercent?: number;\r\n}\r\n\r\n/**\r\n * Mock payment provider for development and testing\r\n */\r\nexport class MockPaymentProvider implements PaymentProvider {\r\n  private config: MockPaymentConfig;\r\n  private confirmedTxHashes: Set<string> = new Set();\r\n  private pendingTxHashes: Set<string> = new Set();\r\n  private failedTxHashes: Set<string> = new Set();\r\n\r\n  constructor(config: MockPaymentConfig = {}) {\r\n    this.config = {\r\n      defaultStatus: config.defaultStatus ?? 'confirmed',\r\n      simulateDelay: config.simulateDelay ?? 100,\r\n      underpaidPercent: config.underpaidPercent ?? 0,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Manually mark a transaction as confirmed\r\n   */\r\n  markConfirmed(txHash: string): void {\r\n    this.confirmedTxHashes.add(txHash);\r\n    this.pendingTxHashes.delete(txHash);\r\n    this.failedTxHashes.delete(txHash);\r\n  }\r\n\r\n  /**\r\n   * Manually mark a transaction as pending\r\n   */\r\n  markPending(txHash: string): void {\r\n    this.pendingTxHashes.add(txHash);\r\n    this.confirmedTxHashes.delete(txHash);\r\n    this.failedTxHashes.delete(txHash);\r\n  }\r\n\r\n  /**\r\n   * Manually mark a transaction as failed\r\n   */\r\n  markFailed(txHash: string): void {\r\n    this.failedTxHashes.add(txHash);\r\n    this.confirmedTxHashes.delete(txHash);\r\n    this.pendingTxHashes.delete(txHash);\r\n  }\r\n\r\n  /**\r\n   * Reset all marked transactions\r\n   */\r\n  reset(): void {\r\n    this.confirmedTxHashes.clear();\r\n    this.pendingTxHashes.clear();\r\n    this.failedTxHashes.clear();\r\n  }\r\n\r\n  async getPaymentStatus(params: {\r\n    chainId: number;\r\n    recipient: string;\r\n    amount: string;\r\n    txHash?: string;\r\n  }): Promise<PaymentStatusResult> {\r\n    // Simulate network delay\r\n    if (this.config.simulateDelay) {\r\n      await new Promise(resolve => setTimeout(resolve, this.config.simulateDelay));\r\n    }\r\n\r\n    if (!params.txHash) {\r\n      return { status: 'not_found' };\r\n    }\r\n\r\n    // Check manually marked statuses first\r\n    if (this.failedTxHashes.has(params.txHash)) {\r\n      return { status: 'failed' };\r\n    }\r\n\r\n    if (this.pendingTxHashes.has(params.txHash)) {\r\n      return { status: 'pending' };\r\n    }\r\n\r\n    if (this.confirmedTxHashes.has(params.txHash)) {\r\n      return this.createConfirmedResult(params);\r\n    }\r\n\r\n    // Use default status\r\n    switch (this.config.defaultStatus) {\r\n      case 'pending':\r\n        return { status: 'pending' };\r\n      case 'failed':\r\n        return { status: 'failed' };\r\n      case 'confirmed':\r\n      default:\r\n        return this.createConfirmedResult(params);\r\n    }\r\n  }\r\n\r\n  private createConfirmedResult(params: {\r\n    amount: string;\r\n    recipient: string;\r\n  }): PaymentStatusResult {\r\n    let actualAmount = params.amount;\r\n\r\n    // Simulate underpayment\r\n    if (this.config.underpaidPercent && this.config.underpaidPercent > 0) {\r\n      const original = parseFloat(params.amount);\r\n      const reduced = original * (1 - this.config.underpaidPercent / 100);\r\n      actualAmount = reduced.toString();\r\n    }\r\n\r\n    const status = compareAmounts(actualAmount, params.amount) < 0 \r\n      ? 'underpaid' \r\n      : 'confirmed';\r\n\r\n    return {\r\n      status,\r\n      actualAmount,\r\n      fromAddress: '0x' + 'a'.repeat(40), // Mock sender address\r\n      raw: {\r\n        mock: true,\r\n        timestamp: Date.now(),\r\n      },\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Create a mock payment provider\r\n */\r\nexport function createMockProvider(config?: MockPaymentConfig): MockPaymentProvider {\r\n  return new MockPaymentProvider(config);\r\n}\r\n","/**\r\n * Portal Token Integration ($PP)\r\n * Native token support for Pay Portal\r\n * \r\n * Token: $PP\r\n * Mint: [REPLACE_WITH_PP_TOKEN_MINT_ADDRESS]\r\n * Chain: Solana\r\n * Decimals: 6 (standard pump.fun token)\r\n * \r\n * ⚠️ CRITICAL: Replace MINT address with actual $PP token mint address before launch\r\n */\r\n\r\nimport type { PaymentCheckResult } from './types.js';\r\n\r\n/**\r\n * Portal Token Constants ($PP)\r\n */\r\nexport const PORTAL_TOKEN = {\r\n  /** Token mint address - ⚠️ REPLACE WITH ACTUAL $PP TOKEN ADDRESS */\r\n  MINT: '[REPLACE_WITH_PP_TOKEN_MINT_ADDRESS]',\r\n  /** Token symbol */\r\n  SYMBOL: 'PP',\r\n  /** Token decimals (pump.fun standard) */\r\n  DECIMALS: 6,\r\n  /** Chain ID (Solana mainnet) */\r\n  CHAIN_ID: 101,\r\n} as const;\r\n\r\n/**\r\n * Discount tiers based on $PP holdings\r\n */\r\nexport interface DiscountTier {\r\n  /** Minimum token balance required */\r\n  minBalance: number;\r\n  /** Discount percentage (0-100) */\r\n  discountPercent: number;\r\n  /** Tier name */\r\n  name: string;\r\n}\r\n\r\n/**\r\n * Default discount tiers\r\n */\r\nexport const DEFAULT_DISCOUNT_TIERS: DiscountTier[] = [\r\n  { minBalance: 1_000_000, discountPercent: 50, name: 'Diamond' },    // 1M tokens = 50% off\r\n  { minBalance: 500_000, discountPercent: 30, name: 'Platinum' },     // 500K tokens = 30% off\r\n  { minBalance: 100_000, discountPercent: 20, name: 'Gold' },         // 100K tokens = 20% off\r\n  { minBalance: 10_000, discountPercent: 10, name: 'Silver' },        // 10K tokens = 10% off\r\n  { minBalance: 1_000, discountPercent: 5, name: 'Bronze' },          // 1K tokens = 5% off\r\n];\r\n\r\n/**\r\n * Portal token configuration ($PP)\r\n */\r\nexport interface PortalTokenConfig {\r\n  /** Solana RPC URL */\r\n  rpcUrl: string;\r\n  /** Enable $PP token payments */\r\n  enableTokenPayments?: boolean;\r\n  /** Discount when paying with $PP (percentage, 0-100) */\r\n  tokenPaymentDiscount?: number;\r\n  /** Enable holder discounts */\r\n  enableHolderDiscounts?: boolean;\r\n  /** Custom discount tiers (optional) */\r\n  discountTiers?: DiscountTier[];\r\n  /** Request timeout in ms */\r\n  timeout?: number;\r\n}\r\n\r\ninterface TokenAccountInfo {\r\n  mint: string;\r\n  owner: string;\r\n  amount: string;\r\n  decimals: number;\r\n}\r\n\r\ninterface JsonRpcResponse<T> {\r\n  jsonrpc: string;\r\n  id: number;\r\n  result?: T;\r\n  error?: { code: number; message: string };\r\n}\r\n\r\n/**\r\n * Portal Token Manager ($PP)\r\n * Handles token balance checks, discounts, and SPL token payment verification\r\n */\r\nexport class PortalTokenManager {\r\n  private config: Required<PortalTokenConfig>;\r\n  private requestId = 0;\r\n\r\n  constructor(config: PortalTokenConfig) {\r\n    this.config = {\r\n      rpcUrl: config.rpcUrl,\r\n      enableTokenPayments: config.enableTokenPayments ?? true,\r\n      tokenPaymentDiscount: config.tokenPaymentDiscount ?? 10,\r\n      enableHolderDiscounts: config.enableHolderDiscounts ?? true,\r\n      discountTiers: config.discountTiers ?? DEFAULT_DISCOUNT_TIERS,\r\n      timeout: config.timeout ?? 30000,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get $PP token balance for a wallet\r\n   */\r\n  async getTokenBalance(walletAddress: string): Promise<number> {\r\n    try {\r\n      const tokenAccounts = await this.getTokenAccountsByOwner(walletAddress);\r\n      \r\n      const portalAccount = tokenAccounts.find(\r\n        acc => acc.mint === PORTAL_TOKEN.MINT\r\n      );\r\n\r\n      if (!portalAccount) {\r\n        return 0;\r\n      }\r\n\r\n      // Convert from raw amount to token amount\r\n      return Number(portalAccount.amount) / Math.pow(10, PORTAL_TOKEN.DECIMALS);\r\n    } catch (error) {\r\n      console.error('Error fetching $PP balance:', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get discount tier for a wallet based on $PP holdings\r\n   */\r\n  async getDiscountTier(walletAddress: string): Promise<DiscountTier | null> {\r\n    if (!this.config.enableHolderDiscounts) {\r\n      return null;\r\n    }\r\n\r\n    const balance = await this.getTokenBalance(walletAddress);\r\n    \r\n    // Sort tiers by minBalance descending to find highest qualifying tier\r\n    const sortedTiers = [...this.config.discountTiers].sort(\r\n      (a, b) => b.minBalance - a.minBalance\r\n    );\r\n\r\n    for (const tier of sortedTiers) {\r\n      if (balance >= tier.minBalance) {\r\n        return tier;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Calculate discounted price based on holder tier\r\n   */\r\n  async calculateDiscountedPrice(\r\n    walletAddress: string,\r\n    originalPrice: number\r\n  ): Promise<{ price: number; discount: number; tier: DiscountTier | null }> {\r\n    const tier = await this.getDiscountTier(walletAddress);\r\n    \r\n    if (!tier) {\r\n      return { price: originalPrice, discount: 0, tier: null };\r\n    }\r\n\r\n    const discount = (originalPrice * tier.discountPercent) / 100;\r\n    const price = originalPrice - discount;\r\n\r\n    return { price, discount, tier };\r\n  }\r\n\r\n  /**\r\n   * Get price when paying with $PP token\r\n   */\r\n  getTokenPaymentPrice(originalPrice: number): number {\r\n    if (!this.config.enableTokenPayments) {\r\n      return originalPrice;\r\n    }\r\n\r\n    const discount = (originalPrice * this.config.tokenPaymentDiscount) / 100;\r\n    return originalPrice - discount;\r\n  }\r\n\r\n  /**\r\n   * Verify $PP token payment\r\n   */\r\n  async verifyTokenPayment(params: {\r\n    txHash: string;\r\n    recipient: string;\r\n    amount: string;\r\n  }): Promise<PaymentCheckResult> {\r\n    try {\r\n      const tx = await this.getTransaction(params.txHash);\r\n\r\n      if (!tx) {\r\n        return { status: 'not_found' };\r\n      }\r\n\r\n      if (tx.meta?.err) {\r\n        return { status: 'failed' };\r\n      }\r\n\r\n      // Parse SPL token transfer\r\n      const transfer = this.parseTokenTransfer(tx, params.recipient);\r\n\r\n      if (!transfer) {\r\n        return { status: 'not_found' };\r\n      }\r\n\r\n      // Verify it's $PP token\r\n      if (transfer.mint !== PORTAL_TOKEN.MINT) {\r\n        return { status: 'not_found' };\r\n      }\r\n\r\n      // Convert amount to token units\r\n      const actualAmount = transfer.amount / Math.pow(10, PORTAL_TOKEN.DECIMALS);\r\n      const requiredAmount = parseFloat(params.amount);\r\n\r\n      if (actualAmount < requiredAmount) {\r\n        return {\r\n          status: 'underpaid',\r\n          actualAmount: actualAmount.toString(),\r\n          fromAddress: transfer.from,\r\n        };\r\n      }\r\n\r\n      return {\r\n        status: 'confirmed',\r\n        actualAmount: actualAmount.toString(),\r\n        fromAddress: transfer.from,\r\n        raw: tx,\r\n      };\r\n    } catch (error) {\r\n      console.error('$PP payment verification error:', error);\r\n      return { status: 'not_found' };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parse SPL token transfer from transaction\r\n   */\r\n  private parseTokenTransfer(\r\n    tx: any,\r\n    expectedRecipient: string\r\n  ): { mint: string; from: string; to: string; amount: number } | null {\r\n    try {\r\n      // Look for token balance changes in postTokenBalances\r\n      const preBalances = tx.meta?.preTokenBalances || [];\r\n      const postBalances = tx.meta?.postTokenBalances || [];\r\n\r\n      // Find $PP transfers to recipient\r\n      for (const post of postBalances) {\r\n        if (post.mint !== PORTAL_TOKEN.MINT) continue;\r\n\r\n        const pre = preBalances.find(\r\n          (p: any) => p.accountIndex === post.accountIndex\r\n        );\r\n\r\n        const preAmount = pre ? Number(pre.uiTokenAmount?.amount || 0) : 0;\r\n        const postAmount = Number(post.uiTokenAmount?.amount || 0);\r\n        const diff = postAmount - preAmount;\r\n\r\n        if (diff > 0) {\r\n          // This account received tokens\r\n          const owner = post.owner;\r\n          \r\n          if (owner?.toLowerCase() === expectedRecipient.toLowerCase()) {\r\n            // Find sender (account with negative diff)\r\n            let sender = '';\r\n            for (const otherPost of postBalances) {\r\n              if (otherPost.mint !== PORTAL_TOKEN.MINT) continue;\r\n              const otherPre = preBalances.find(\r\n                (p: any) => p.accountIndex === otherPost.accountIndex\r\n              );\r\n              const otherPreAmount = otherPre ? Number(otherPre.uiTokenAmount?.amount || 0) : 0;\r\n              const otherPostAmount = Number(otherPost.uiTokenAmount?.amount || 0);\r\n              if (otherPostAmount - otherPreAmount < 0) {\r\n                sender = otherPost.owner || '';\r\n                break;\r\n              }\r\n            }\r\n\r\n            return {\r\n              mint: PORTAL_TOKEN.MINT,\r\n              from: sender,\r\n              to: owner,\r\n              amount: diff,\r\n            };\r\n          }\r\n        }\r\n      }\r\n\r\n      return null;\r\n    } catch {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get token accounts for a wallet\r\n   */\r\n  private async getTokenAccountsByOwner(owner: string): Promise<TokenAccountInfo[]> {\r\n    const result = await this.rpc<{\r\n      value: Array<{\r\n        account: {\r\n          data: {\r\n            parsed: {\r\n              info: TokenAccountInfo;\r\n            };\r\n          };\r\n        };\r\n      }>;\r\n    }>('getTokenAccountsByOwner', [\r\n      owner,\r\n      { programId: 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' },\r\n      { encoding: 'jsonParsed' },\r\n    ]);\r\n\r\n    if (!result?.value) {\r\n      return [];\r\n    }\r\n\r\n    return result.value.map(item => item.account.data.parsed.info);\r\n  }\r\n\r\n  /**\r\n   * Get transaction details\r\n   */\r\n  private async getTransaction(signature: string): Promise<any> {\r\n    return this.rpc('getTransaction', [\r\n      signature,\r\n      {\r\n        encoding: 'jsonParsed',\r\n        commitment: 'confirmed',\r\n        maxSupportedTransactionVersion: 0,\r\n      },\r\n    ]);\r\n  }\r\n\r\n  /**\r\n   * Make RPC call\r\n   */\r\n  private async rpc<T>(method: string, params: unknown[]): Promise<T | null> {\r\n    const controller = new AbortController();\r\n    const timeout = setTimeout(() => controller.abort(), this.config.timeout);\r\n\r\n    try {\r\n      const response = await fetch(this.config.rpcUrl, {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify({\r\n          jsonrpc: '2.0',\r\n          id: ++this.requestId,\r\n          method,\r\n          params,\r\n        }),\r\n        signal: controller.signal,\r\n      });\r\n\r\n      const data = (await response.json()) as JsonRpcResponse<T>;\r\n\r\n      if (data.error) {\r\n        console.error('RPC error:', data.error);\r\n        return null;\r\n      }\r\n\r\n      return data.result ?? null;\r\n    } catch (error) {\r\n      console.error('RPC request failed:', error);\r\n      return null;\r\n    } finally {\r\n      clearTimeout(timeout);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Create a $PP token manager\r\n */\r\nexport function createPortalTokenManager(config: PortalTokenConfig): PortalTokenManager {\r\n  return new PortalTokenManager(config);\r\n}\r\n\r\n/**\r\n * Check if a token symbol is $PP\r\n */\r\nexport function isPortalToken(symbol: string): boolean {\r\n  return symbol.toUpperCase() === PORTAL_TOKEN.SYMBOL;\r\n}\r\n\r\n/**\r\n * Format $PP amount for display\r\n */\r\nexport function formatPortalAmount(amount: number): string {\r\n  if (amount >= 1_000_000) {\r\n    return `${(amount / 1_000_000).toFixed(2)}M`;\r\n  }\r\n  if (amount >= 1_000) {\r\n    return `${(amount / 1_000).toFixed(2)}K`;\r\n  }\r\n  return amount.toFixed(2);\r\n}\r\n"],"mappings":"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","names":["ReasonCode","createHmac","MemoryStorage"]}